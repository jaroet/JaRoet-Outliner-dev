<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="./jr_favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JaRoet Outliner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
      }
    </script>
    <style>
      :root {
        --main-color: #60a5fa;
        --font-family: sans-serif;
        --font-size: 16px;
      }
      body {
        font-family: var(--font-family);
        font-size: var(--font-size);
        overflow: hidden; /* Prevent body scroll when resizing */
        line-height: 1.5;
      }

      /* Ensure form elements inherit font settings from body */
      input, textarea, button, select {
        font-family: inherit;
        font-size: inherit;
      }

      /* Simple scrollbar styling for a more modern look */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      /* Light theme */
      ::-webkit-scrollbar-track {
        background: #f1f5f9; /* cool-gray-100 */
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1; /* cool-gray-300 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8; /* cool-gray-400 */
      }
      /* Dark theme */
      .dark ::-webkit-scrollbar-track {
        background: #1e293b; /* slate-800 */
      }
      .dark ::-webkit-scrollbar-thumb {
        background: #475569; /* slate-600 */
      }
      .dark ::-webkit-scrollbar-thumb:hover {
        background: #64748b; /* slate-500 */
      }
      .focus-outline {
        outline: 2px solid var(--main-color);
        outline-offset: -1px;
        border-radius: 4px;
      }
      .selected-item-bg {
        /* Mix with 20% black to darken the main color, ensuring good contrast with white text */
        background-color: color-mix(in srgb, var(--main-color) 80%, black);
      }
      .tag-span {
        background-color: color-mix(in srgb, var(--main-color) 20%, transparent);
        color: color-mix(in srgb, var(--main-color) 70%, black);
        border-radius: 0.375rem; /* rounded-md */
        padding: 0.125rem 0.25rem; /* py-0.5 px-1 */
        margin: 0 0.0625rem; /* mx-px */
        font-size: 0.875rem; /* text-sm */
      }

      .dark .tag-span {
        color: var(--main-color);
      }

      @keyframes fadeInUp {
          from {
              opacity: 0;
              transform: translate3d(0, 100%, 0);
          }
          to {
              opacity: 1;
              transform: translate3d(0, 0, 0);
          }
      }

      .animate-fade-in-up {
          animation: fadeInUp 0.3s ease-out;
      }
    </style>
    <!-- Add Babel for in-browser JSX/TS transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Add Dexie.js for IndexedDB -->
    <script src="https://unpkg.com/dexie@4.0.7/dist/dexie.js"></script>
    <!-- Configure Babel -->
    <script>
      Babel.config({
        presets: [
          ["env", { "modules": false }],
          "react",
          "typescript"
        ]
      });
    </script>
    <script type="importmap">
    {
      "imports": {
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react/": "https://aistudiocdn.com/react@^19.2.0/",
        "react-dom": "https://aistudiocdn.com/react-dom@^19.2.0",
        "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
        "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client"
      }
    }
    </script>
</head>
  <body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 antialiased transition-colors duration-200">
    <div id="root"></div>
    
    <script>
      // Polyfill for crypto.randomUUID if not available
      if (!crypto.randomUUID) {
        crypto.randomUUID = () => {
          if (crypto.getRandomValues) {
             return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
               (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
             );
          } else {
             return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
             });
          }
        };
      }
    </script>

    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
      import { createRoot } from 'react-dom/client';

      // ==========================================
      // 1. TYPES
      // ==========================================
      
      export interface Bullet {
        id: string;
        text: string;
        children: Bullet[];
        isCollapsed: boolean;
        isReadOnly?: boolean;
        isFavorite?: boolean;
        originalId?: string;
        createdAt?: number;
        updatedAt?: number;
      }

      export interface FlatBullet {
        id: string;
        text: string;
        path: string[];
        createdAt?: number;
        updatedAt?: number;
      }

      export interface Settings {
        mainColor: string;
        fileName: string;
        fontFamily: string;
        fontSize: number;
      }

      export type CoreBullet = {
        id: string;
        text: string;
        children: CoreBullet[];
        isFavorite?: boolean;
        originalId?: string;
        createdAt?: number;
        updatedAt?: number;
      };

      // ==========================================
      // 2. ICONS
      // ==========================================

      const ChevronRightIcon = ({ className = 'w-4 h-4' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
        </svg>
      );

      const ChevronDownIcon = ({ className = 'w-4 h-4' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
        </svg>
      );

      const CircleIcon = ({ className = 'w-2 h-2', color = 'var(--main-color)' }) => (
        <svg viewBox="0 0 100 100" className={className}>
          <circle cx="50" cy="50" r="50" fill={color} />
        </svg>
      );

      const SearchIcon = ({ className = 'w-5 h-5' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
        </svg>
      );

      const UploadIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
          </svg>
      );

      const DownloadIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" />
          </svg>
      );

      const HomeIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
            <path d="M11.47 3.84a.75.75 0 011.06 0l8.69 8.69a.75.75 0 101.06-1.06l-8.689-8.69a2.25 2.25 0 00-3.182 0l-8.69 8.69a.75.75 0 001.061 1.06l8.69-8.69z" />
            <path d="M12 5.432L4.432 13v6.75a2.25 2.25 0 002.25 2.25h10.636a2.25 2.25 0 002.25-2.25v-6.75L12 5.432z" />
          </svg>
      );

      const AppointmentIcon = ({ className = 'w-4 h-4' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0h18" />
          </svg>
      );

      const SettingsIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.242 1.41l-1.028.937c-.28.254-.434.62-.434.995s.154.74.434.995l1.028.937a1.125 1.125 0 01-.242 1.41l1.296-2.247a1.125 1.125 0 011.37.49l1.217.456c.355.133.75.072 1.075-.124a6.57 6.57 0 01-.22.127c-.331.183-.581.495-.645.87l-.213 1.281c-.09.543-.56.94-1.11.94h-2.593c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.063-.374-.313-.686-.645-.87a6.52 6.52 0 01-.22-.127c-.324-.196-.72-.257-1.075-.124l-1.217.456a1.125 1.125 0 01-1.37-.49l-1.296-2.247a1.125 1.125 0 01.242-1.41l1.028-.937c.28-.254.434.62.434.995s-.154-.74-.434-.995l-1.028-.937a1.125 1.125 0 01-.242-1.41l1.296-2.247a1.125 1.125 0 011.37.49l1.217.456c.355.133.75.072 1.075-.124.073-.044.146-.087.22-.127.332-.183.582-.495.645-.87l.213-1.281z" />
              <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg>
      );

      const SunIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.95-4.223-1.591 1.591M5.25 12H3m4.223-4.95-1.591-1.591M12 6a6 6 0 1 0 0 12 6 6 0 0 0 0-12Z" />
          </svg>
      );

      const MoonIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25c0 5.385 4.365 9.75 9.75 9.75 2.806 0 5.347-1.257 7.141-3.248a9.753 9.753 0 0 1 1.861-3.75Z" />
          </svg>
      );

      const TrashIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" />
          </svg>
      );

      const SidebarIcon = ({ className = 'w-5 h-5' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
        </svg>
      );

      const ClockIcon = ({ className = 'w-4 h-4' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
          </svg>
      );

      const StarIcon = ({ className = 'w-5 h-5', filled = false }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill={filled ? "currentColor" : "none"} viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M11.48 3.499a.562.562 0 0 1 1.04 0l2.125 5.111a.563.563 0 0 0 .475.345l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 0 0-.182.557l1.285 5.385a.562.562 0 0 1-.84.61l-4.725-2.885a.562.562 0 0 0-.586 0L6.982 20.54a.562.562 0 0 1-.84-.61l1.285-5.386a.562.562 0 0 0-.182-.557l-4.204-3.602a.562.562 0 0 1 .321-.988l5.518-.442a.563.563 0 0 0 .475-.345L11.48 3.5Z" />
          </svg>
      );

      // ==========================================
      // 3. TOAST COMPONENT
      // ==========================================

      const useToast = () => {
          const [toasts, setToasts] = useState([]);

          const addToast = useCallback((message, type = 'info') => {
              const id = crypto.randomUUID();
              setToasts(prev => [...prev, { id, message, type }]);
              setTimeout(() => {
                  setToasts(prev => prev.filter(t => t.id !== id));
              }, 3000);
          }, []);

          const removeToast = useCallback((id) => {
              setToasts(prev => prev.filter(t => t.id !== id));
          }, []);

          return { toasts, addToast, removeToast };
      };

      const ToastContainer = ({ toasts, removeToast }) => {
          return (
              <div className="fixed bottom-10 left-1/2 transform -translate-x-1/2 flex flex-col gap-2 z-50 pointer-events-none">
                  {toasts.map(toast => (
                      <div
                          key={toast.id}
                          className={`px-4 py-2 rounded-md shadow-lg text-white text-sm font-medium transition-all duration-300 animate-fade-in-up pointer-events-auto ${
                              toast.type === 'success' ? 'bg-green-600' : 
                              toast.type === 'error' ? 'bg-red-600' : 
                              'bg-gray-800 dark:bg-gray-600'
                          }`}
                          onClick={() => removeToast(toast.id)}
                      >
                          {toast.message}
                      </div>
                  ))}
              </div>
          );
      };

      // ==========================================
      // 4. HELPER COMPONENTS
      // ==========================================

      const navigateSuggestions = (prevState, direction) => {
          const { suggestions, selectedIndex } = prevState; 
          const count = suggestions.length; 
          if (count === 0) return selectedIndex;
          if (direction === 'down') {
              return (selectedIndex + 1) % count;
          } else { 
              return (selectedIndex - 1 + count) % count;
          }
      };

      const LinkPopup = ({ suggestions, selectedIndex, onSelect, position, containerRef }) => {
        const selectedItemRef = useRef(null);
        
        useEffect(() => {
          if (selectedItemRef.current) {
              selectedItemRef.current.scrollIntoView({ block: 'nearest' });
          }
        }, [selectedIndex]);

        if (suggestions.length === 0) return null;

        return (
          <div
            className="absolute z-20 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto w-full max-w-2xl"
            style={{ top: position.top, left: position.left }}
          >
            <ul ref={containerRef}>
              {suggestions.map((bullet, index) => (
                <li key={bullet.id} ref={index === selectedIndex ? selectedItemRef : null}>
                  <button
                    onClick={() => onSelect(bullet)}
                    className={`w-full text-left px-3 py-2 text-sm ${
                      index === selectedIndex ? 'selected-item-bg text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'
                    }`}
                     title={bullet.text}
                  >
                    <span className="truncate block">{bullet.text || <em>Untitled</em>}</span>
                    {bullet.path.length > 0 && (
                        <span className={`text-xs truncate block ${
                          index === selectedIndex ? 'text-white/80' : 'text-gray-400 dark:text-gray-500'
                        }`}>{bullet.path.join(' / ')}</span>
                    )}
                  </button>
                </li>
              ))}
            </ul>
          </div>
        );
      };

      const TagPopup = ({ suggestions, selectedIndex, onSelect, position, containerRef }) => {
        const selectedItemRef = useRef(null);
        
        useEffect(() => {
          if (selectedItemRef.current) {
              selectedItemRef.current.scrollIntoView({ block: 'nearest' });
          }
        }, [selectedIndex]);

        if (suggestions.length === 0) {
          return null;
        }

        return (
          <div
            className="absolute z-20 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto w-auto min-w-[150px]"
            style={{ top: position.top, left: position.left }}
          >
            <ul ref={containerRef}>
              {suggestions.map((tag, index) => (
                <li key={tag} ref={index === selectedIndex ? selectedItemRef : null}>
                  <button
                    onClick={() => onSelect(tag)}
                    className={`w-full text-left px-3 py-2 text-sm ${
                      index === selectedIndex ? 'selected-item-bg text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'
                    }`}
                     title={tag}
                  >
                    <span className="truncate block">{tag}</span>
                  </button>
                </li>
              ))}
            </ul>
          </div>
        );
      };

      const ImportSelectionModal = ({ isOpen, onClose, onConfirm, bullets }) => {
          const [searchQuery, setSearchQuery] = useState('');
          const [selectedId, setSelectedId] = useState(null);
          const searchInputRef = useRef(null);

          useEffect(() => {
              if (isOpen) {
                  setSearchQuery('');
                  setSelectedId(null); 
                  setTimeout(() => {
                      searchInputRef.current?.focus();
                  }, 50);
              }
          }, [isOpen]);

          const flatBullets = useMemo(() => {
              if (!isOpen) return [];
              const results = [];
              const traverse = (nodes, currentPath) => {
                  for (const node of nodes) {
                      results.push({
                          id: node.id,
                          text: node.text,
                          path: currentPath,
                          createdAt: node.createdAt,
                          updatedAt: node.updatedAt,
                      });
                      if (node.children && node.children.length > 0) {
                          traverse(node.children, [...currentPath, node.text || 'Untitled']);
                      }
                  }
              };
              traverse(bullets, []);
              return results;
          }, [bullets, isOpen]);

          const filteredBullets = useMemo(() => {
              if (!searchQuery.trim()) return [];
              const lowerQuery = searchQuery.toLowerCase();
              return flatBullets.filter(b => b.text.toLowerCase().includes(lowerQuery)).slice(0, 50);
          }, [flatBullets, searchQuery]);

          if (!isOpen) return null;

          return (
              <div 
                  className="fixed inset-0 bg-black/60 z-40 flex justify-center items-center"
                  onClick={onClose}
              >
                  <div 
                      className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md overflow-hidden flex flex-col max-h-[80vh]"
                      onClick={e => e.stopPropagation()}
                  >
                      <div className="p-4 border-b border-gray-200 dark:border-gray-700">
                          <h2 className="text-lg font-semibold text-gray-800 dark:text-gray-200">Import Content</h2>
                          <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                              Where do you want to place the imported items?
                          </p>
                      </div>

                      <div className="p-4 overflow-y-auto flex-grow">
                          <div 
                              onClick={() => setSelectedId(null)}
                              className={`p-3 rounded-md cursor-pointer border transition-colors flex items-center gap-3 mb-4 ${
                                  selectedId === null 
                                      ? 'bg-[var(--main-color)]/10 border-[var(--main-color)]' 
                                      : 'border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700'
                              }`}
                          >
                              <div className={`w-4 h-4 rounded-full border flex items-center justify-center ${
                                  selectedId === null 
                                      ? 'border-[var(--main-color)]' 
                                      : 'border-gray-400'
                              }`}>
                                  {selectedId === null && <div className="w-2 h-2 rounded-full bg-[var(--main-color)]" />}
                              </div>
                              <div>
                                  <span className="block font-medium text-gray-800 dark:text-gray-200">Root (Top Level)</span>
                                  <span className="text-xs text-gray-500 dark:text-gray-400">Add as new items at the bottom of your outline</span>
                              </div>
                          </div>

                          <div className="relative">
                              <div className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Or select a specific item:</div>
                              <input
                                  ref={searchInputRef}
                                  type="text"
                                  placeholder="Search for an item..."
                                  value={searchQuery}
                                  onChange={(e) => setSearchQuery(e.target.value)}
                                  className="w-full bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)] mb-2"
                              />
                              
                              <div className="max-h-40 overflow-y-auto border border-gray-200 dark:border-gray-700 rounded-md">
                                  {filteredBullets.length > 0 ? (
                                      <ul>
                                          {filteredBullets.map(bullet => (
                                              <li 
                                                  key={bullet.id}
                                                  onClick={() => setSelectedId(bullet.id)}
                                                  className={`px-3 py-2 cursor-pointer flex items-center gap-2 text-sm ${
                                                      selectedId === bullet.id 
                                                          ? 'selected-item-bg text-white' 
                                                          : 'hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-800 dark:text-gray-200'
                                                  }`}
                                              >
                                                  <CircleIcon className="w-1.5 h-1.5 flex-shrink-0" />
                                                  <span className="truncate">{bullet.text || <em>Untitled</em>}</span>
                                              </li>
                                          ))}
                                      </ul>
                                  ) : (
                                      <div className="p-2 text-center text-xs text-gray-500 dark:text-gray-400">
                                          {searchQuery ? 'No items found' : 'Type to search...'}
                                      </div>
                                  )}
                              </div>
                          </div>
                      </div>

                      <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end gap-2">
                          <button 
                              onClick={onClose}
                              className="px-4 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-600 dark:hover:bg-gray-500 dark:text-white"
                          >
                              Cancel
                          </button>
                          <button 
                              onClick={() => onConfirm(selectedId)}
                              className="px-4 py-2 rounded-md bg-[var(--main-color)] text-white hover:opacity-90"
                          >
                              Import
                          </button>
                      </div>
                  </div>
              </div>
          );
      };

      const SearchModal = ({ isOpen, onClose, bullets, onNavigate, initialQuery }) => {
          const [query, setQuery] = useState('');
          const [selectedIndex, setSelectedIndex] = useState(0);
          const [activeTab, setActiveTab] = useState('search');
          const inputRef = useRef(null);
          const listRef = useRef(null);
          const selectedItemRef = useRef(null);
          const tagPopupRef = useRef(null);

          const [tagPopupState, setTagPopupState] = useState({
            isOpen: false,
            suggestions: [],
            selectedIndex: 0,
          });

          const flatBullets = useMemo(() => {
              if (!isOpen) return [];
              const results = [];
              const traverse = (nodes, currentPath) => {
                  for (const node of nodes) {
                      results.push({
                          id: node.id,
                          text: node.text,
                          path: currentPath,
                          createdAt: node.createdAt,
                          updatedAt: node.updatedAt,
                      });
                      if (node.children && node.children.length > 0) {
                          traverse(node.children, [...currentPath, node.text || 'Untitled']);
                      }
                  }
              };
              traverse(bullets, []);
              return results;
          }, [bullets, isOpen]);

          const allTags = useMemo(() => {
              if (!isOpen) return [];
              const tagSet = new Set();
              const tagRegex = /#\w+/g;
              for (const bullet of flatBullets) {
                  const matches = bullet.text.match(tagRegex);
                  if (matches) {
                      matches.forEach(tag => tagSet.add(tag));
                  }
              }
              return Array.from(tagSet).sort();
          }, [flatBullets, isOpen]);

          useEffect(() => {
            if (isOpen) {
              inputRef.current?.focus();
              setQuery(initialQuery || '');
              setSelectedIndex(0);
              setActiveTab('search');
              setTagPopupState(prev => (prev.isOpen ? { ...prev, isOpen: false } : prev));
            }
          }, [isOpen, initialQuery]);
          
          useEffect(() => {
            setSelectedIndex(0);
          }, [query, activeTab]);

          const listContent = useMemo(() => {
            let sourceList;
            if (activeTab === 'edited') {
                sourceList = [...flatBullets].sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
            } else if (activeTab === 'created') {
                sourceList = [...flatBullets].sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
            } else {
                sourceList = flatBullets;
            }

            const trimmedQuery = query.trim();
            if (!trimmedQuery) {
              return sourceList;
            }

            const lowerCaseQuery = trimmedQuery.toLowerCase();
            const orClauses = lowerCaseQuery.split(/\s+or\s+/i);
            const searchConditionGroups = orClauses.map(clause => 
                clause.split(/\s+/).filter(term => term)
            );

            return sourceList.filter(bullet => {
                const lowerCaseText = bullet.text.toLowerCase();
                return searchConditionGroups.some(andTerms => {
                    return andTerms.every(term => lowerCaseText.includes(term));
                });
            });
          }, [query, flatBullets, activeTab]);

          useEffect(() => {
            if (selectedItemRef.current) {
              selectedItemRef.current.scrollIntoView({ block: 'nearest' });
            }
          }, [selectedIndex]);

          const handleCloseTagPopup = useCallback(() => {
            setTagPopupState(prev => (prev.isOpen ? { ...prev, isOpen: false } : prev));
          }, []);

          const handleTagSelection = useCallback((selectedTag) => {
            const input = inputRef.current;
            if (!input) return;

            const text = input.value;
            const cursor = input.selectionStart ?? text.length;

            const textBeforeCursor = text.substring(0, cursor);
            const match = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);

            if (match) {
                const startIndex = match.index + (match[0].startsWith(' ') ? 1 : 0);
                const newText = text.substring(0, startIndex) + selectedTag + ' ' + text.substring(cursor);
                setQuery(newText);
                handleCloseTagPopup();

                setTimeout(() => {
                    const newCursorPos = startIndex + selectedTag.length + 1;
                    input.focus();
                    input.setSelectionRange(newCursorPos, newCursorPos);
                }, 0);
            }
          }, [handleCloseTagPopup]);

          const handleQueryChange = (e) => {
            const text = e.target.value;
            const cursor = e.target.selectionStart;
            setQuery(text);

            if (cursor === null) {
              handleCloseTagPopup();
              return;
            }

            const textBeforeCursor = text.substring(0, cursor);
            const tagMatch = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);
            
            if (tagMatch) {
                const query = tagMatch[1];
                const lowerCaseQuery = query.toLowerCase();
                const suggestions = allTags.filter(tag => tag.toLowerCase().includes(lowerCaseQuery));

                if (suggestions.length > 0) {
                    setTagPopupState({
                        isOpen: true,
                        suggestions: suggestions.slice(0, 100),
                        selectedIndex: 0,
                    });
                } else {
                    handleCloseTagPopup();
                }
            } else {
                handleCloseTagPopup();
            }
          };

          const handleKeyDown = (e) => {
            if (tagPopupState.isOpen && tagPopupState.suggestions.length > 0) {
                let handled = true;
                switch (e.key) {
                    case 'ArrowUp':
                        setTagPopupState(prev => ({
                            ...prev,
                            selectedIndex: (prev.selectedIndex - 1 + prev.suggestions.length) % prev.suggestions.length,
                        }));
                        break;
                    case 'ArrowDown':
                        setTagPopupState(prev => ({
                            ...prev,
                            selectedIndex: (prev.selectedIndex + 1) % prev.suggestions.length,
                        }));
                        break;
                    case 'Tab':
                        const selectedTag = tagPopupState.suggestions[tagPopupState.selectedIndex];
                        handleTagSelection(selectedTag);
                        break;
                    case 'Escape':
                        handleCloseTagPopup();
                        break;
                    default:
                        handled = false;
                }
                if (handled) {
                    e.preventDefault();
                    return;
                }
            }

            if (e.ctrlKey) {
                const tabs = ['search', 'edited', 'created'];
                const currentIndex = tabs.indexOf(activeTab);
                let handled = true;

                if (e.key === 'ArrowRight') {
                    const nextIndex = (currentIndex + 1) % tabs.length;
                    setActiveTab(tabs[nextIndex]);
                } else if (e.key === 'ArrowLeft') {
                    const nextIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                    setActiveTab(tabs[nextIndex]);
                } else {
                    handled = false;
                }

                if (handled) {
                    e.preventDefault();
                    return;
                }
            }

            const count = listContent.length;
            if (e.key === 'Escape') {
              onClose();
              return;
            }

            if (count === 0 && e.key !== 'Enter') return;

            if (e.key === 'ArrowDown') {
              e.preventDefault();
              setSelectedIndex(prev => (prev + 1) % count);
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              setSelectedIndex(prev => (prev - 1 + count) % count);
            } else if (e.key === 'Enter') {
              e.preventDefault();
              if (listContent.length > 0 && listContent[selectedIndex]) {
                onNavigate(listContent[selectedIndex].id);
              }
            }
          };

          const highlightMatch = (text, q) => {
              const trimmedQuery = q.trim();
              if (!trimmedQuery || !text) return text;
              const termsToHighlight = trimmedQuery.toLowerCase().replace(/\s+or\s+/gi, ' ').split(/\s+/).filter(Boolean);
              const uniqueTerms = [...new Set(termsToHighlight)];
              if (uniqueTerms.length === 0) return text;
              const regex = new RegExp(`(${uniqueTerms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})`, 'gi');
              const parts = text.split(regex);
              return (
                  <span>
                      {parts.map((part, i) => {
                          if (part && uniqueTerms.some(term => term === part.toLowerCase())) {
                              return <span key={i} className="bg-yellow-400/40 dark:bg-yellow-600/40 rounded-sm">{part}</span>;
                          }
                          return part;
                      })}
                  </span>
              );
          };

          const formatDateTime = (timestamp) => {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            return date.toLocaleString(undefined, {
              year: 'numeric', month: 'short', day: 'numeric',
              hour: 'numeric', minute: '2-digit', hour12: false,
            });
          };

          if (!isOpen) {
            return null;
          }

          return (
            <div
              className="fixed inset-0 bg-black/40 dark:bg-black/60 z-30 flex justify-center items-start pt-20"
              onClick={onClose}
            >
              <div
                className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[70vh] flex flex-col"
                onClick={e => e.stopPropagation()}
              >
                <div className="p-4 border-b border-gray-200 dark:border-gray-700 text-[var(--main-color)]">
                    <div className="relative">
                        <span className="absolute inset-y-0 left-0 flex items-center pl-3">
                            <SearchIcon />
                        </span>
                        <input
                            ref={inputRef}
                            type="text"
                            placeholder="Quick find... (use #tag, AND, OR)"
                            value={query}
                            onChange={handleQueryChange}
                            onKeyDown={handleKeyDown}
                            className="w-full bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 pl-10 pr-4 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]"
                        />
                         {tagPopupState.isOpen && inputRef.current && (
                            <TagPopup
                                suggestions={tagPopupState.suggestions}
                                selectedIndex={tagPopupState.selectedIndex}
                                onSelect={handleTagSelection}
                                position={{
                                    top: inputRef.current.offsetHeight + 4,
                                    left: 0
                                }}
                                containerRef={tagPopupRef}
                            />
                        )}
                    </div>
                    <div className="mt-3 flex border-b border-gray-200 dark:border-gray-700 text-sm">
                        {['search', 'edited', 'created'].map(tab => (
                            <button
                                key={tab}
                                onClick={() => setActiveTab(tab)}
                                className={`px-4 py-2 capitalize -mb-px border-b-2 transition-colors ${
                                    activeTab === tab 
                                        ? 'border-[var(--main-color)] text-[var(--main-color)]' 
                                        : 'border-transparent text-gray-500 hover:text-gray-800 dark:hover:text-gray-200'
                                }`}
                            >
                                {tab === 'edited' ? 'Recently modified' : (tab === 'created' ? 'Recently created' : 'Search')}
                            </button>
                        ))}
                    </div>
                </div>

                <div className="overflow-y-auto">
                  {listContent.length > 0 ? (
                    <ul ref={listRef}>
                      {listContent.map((bullet, index) => (
                        <li
                          key={bullet.id}
                          ref={index === selectedIndex ? selectedItemRef : null}
                          className={`cursor-pointer transition-colors duration-75 ${index === selectedIndex ? 'selected-item-bg text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'}`}
                          onClick={() => onNavigate(bullet.id)}
                        >
                          <div className="px-4 py-2 border-b border-gray-200/50 dark:border-gray-700/50">
                            <div className="flex justify-between items-start gap-4">
                                <div className={`text-sm font-medium truncate mb-1 flex-grow ${index === selectedIndex ? 'text-white' : 'text-gray-800 dark:text-gray-200'}`}>
                                    {highlightMatch(bullet.text, query) || <em>Untitled</em>}
                                </div>
                                <div className={`text-xs flex-shrink-0 whitespace-nowrap ${index === selectedIndex ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'}`}>
                                    {formatDateTime(activeTab === 'created' ? bullet.createdAt : bullet.updatedAt)}
                                </div>
                            </div>
                            <div className={`text-xs flex flex-wrap items-center gap-1 leading-none ${
                                index === selectedIndex ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'
                            }`}>
                                {bullet.path.length > 0 ? (
                                    bullet.path.map((segment, i) => (
                                        <React.Fragment key={i}>
                                            <span className="truncate max-w-[200px]" title={segment}>{segment}</span>
                                            {i < bullet.path.length - 1 && (
                                                <span className="opacity-50 flex-shrink-0">/</span>
                                            )}
                                        </React.Fragment>
                                    ))
                                ) : (
                                     <span className="italic opacity-50">Top level</span>
                                )}
                            </div>
                          </div>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <p className="text-gray-400 dark:text-gray-500 p-4 text-center">No results found.</p>
                  )}
                </div>
              </div>
            </div>
          );
      };

      // ==========================================
      // 5. SIDEBAR & TOOLBAR
      // ==========================================

      const LeftSidebar = React.memo(({ isOpen, recents, favorites, onNavigate }) => {
        const [width, setWidth] = useState(256);
        const [isRecentsCollapsed, setIsRecentsCollapsed] = useState(false);
        const [isFavoritesCollapsed, setIsFavoritesCollapsed] = useState(false);
        const [isResizing, setIsResizing] = useState(false);

        const startResizing = useCallback((mouseDownEvent) => {
            mouseDownEvent.preventDefault();
            setIsResizing(true);
            const startX = mouseDownEvent.clientX;
            const startWidth = width;

            const doDrag = (mouseMoveEvent) => {
                const newWidth = startWidth + (mouseMoveEvent.clientX - startX);
                if (newWidth > 150 && newWidth < 600) {
                    setWidth(newWidth);
                }
            };

            const stopDrag = () => {
                setIsResizing(false);
                document.removeEventListener('mousemove', doDrag);
                document.removeEventListener('mouseup', stopDrag);
            };

            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDrag);
        }, [width]);

        if (!isOpen) return null;

        return (
          <div 
            className="flex-shrink-0 border-r border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900/50 flex flex-col h-full relative group/sidebar"
            style={{ width: `${width}px`, fontSize: 'calc(var(--font-size) * 0.87)' }}
          >
             <div className={`absolute right-[-2px] top-0 bottom-0 w-1 cursor-col-resize z-10 hover:bg-blue-400/50 transition-colors ${isResizing ? 'bg-blue-400/50' : ''}`} onMouseDown={startResizing} />
             <div className="flex flex-col h-full overflow-y-auto overflow-x-hidden">
                {/* Favorites */}
                <div>
                    <div className="p-3 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between text-gray-600 dark:text-gray-300 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-800/50 select-none" onClick={() => setIsFavoritesCollapsed(!isFavoritesCollapsed)}>
                        <div className="flex items-center gap-2"><StarIcon className="w-4 h-4" /><span className="font-bold text-[length:var(--font-size)]">Favorites</span></div>
                        <button className="text-gray-400">{isFavoritesCollapsed ? <ChevronRightIcon className="w-4 h-4" /> : <ChevronDownIcon className="w-4 h-4" />}</button>
                    </div>
                    {!isFavoritesCollapsed && (
                        <div className="p-2">
                            {favorites.length === 0 ? <div className="text-xs text-gray-400 dark:text-gray-500 text-center my-2 italic">No favorites yet</div> : (
                                <ul className="space-y-0">{favorites.map(item => (
                                    <li key={item.id}><button onClick={() => onNavigate(item.id)} className="w-full text-left px-3 py-0 rounded-md hover:bg-gray-200 dark:hover:bg-gray-800 transition-colors group"><div className="text-gray-800 dark:text-gray-200 truncate font-medium">{item.text || <em className="text-gray-400">Untitled</em>}</div></button></li>
                                ))}</ul>
                            )}
                        </div>
                    )}
                </div>
                {/* Recents */}
                <div className="border-t border-gray-200 dark:border-gray-700">
                    <div className="p-3 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between text-gray-600 dark:text-gray-300 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-800/50 select-none" onClick={() => setIsRecentsCollapsed(!isRecentsCollapsed)}>
                        <div className="flex items-center gap-2"><ClockIcon className="w-4 h-4" /><span className="font-bold text-[length:var(--font-size)]">Recents</span></div>
                        <button className="text-gray-400">{isRecentsCollapsed ? <ChevronRightIcon className="w-4 h-4" /> : <ChevronDownIcon className="w-4 h-4" />}</button>
                    </div>
                    {!isRecentsCollapsed && (
                        <div className="p-2">
                            {recents.length === 0 ? <div className="text-xs text-gray-400 dark:text-gray-500 text-center my-2 italic">No recent changes</div> : (
                                <ul className="space-y-0">{recents.map(item => (
                                    <li key={item.id}><button onClick={() => onNavigate(item.id)} className="w-full text-left px-3 py-0 rounded-md hover:bg-gray-200 dark:hover:bg-gray-800 transition-colors group"><div className="text-gray-800 dark:text-gray-200 truncate font-medium">{item.text || <em className="text-gray-400">Untitled</em>}</div></button></li>
                                ))}</ul>
                            )}
                        </div>
                    )}
                </div>
            </div>
          </div>
        );
      });

      const Toolbar = React.memo(({ onImport, onExport, breadcrumbs, onBreadcrumbClick, fileName, onOpenSettings, onGoToToday, theme, onThemeToggle, onOpenSearch, isSidebarOpen, onToggleSidebar, isFavorite, onToggleFavorite, canFavorite }) => {
          const fileInputRef = useRef(null);
          const handleImportClick = () => fileInputRef.current?.click();
          const handleFileChange = (event) => {
              const file = event.target.files?.[0];
              if (file) {
                  const reader = new FileReader();
                  reader.onload = (e) => {
                      try {
                          const data = JSON.parse(e.target.result);
                          if (Array.isArray(data) && data.every(item => 'id' in item && 'text' in item)) onImport(data);
                          else alert('Invalid JSON file format.');
                      } catch (error) { alert('Error parsing JSON file.'); }
                  };
                  reader.readAsText(file);
              }
              if(event.target) event.target.value = '';
          };
          return (
            <div className="flex-shrink-0 sticky top-0 z-20 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-2 flex items-center gap-4 border-b border-gray-200 dark:border-gray-700 text-[var(--main-color)]">
                <button onClick={onToggleSidebar} className={`p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${isSidebarOpen ? 'bg-gray-100 dark:bg-gray-700' : ''}`} title={isSidebarOpen ? "Hide Sidebar" : "Show Sidebar"}><SidebarIcon /></button>
                <div className="flex-grow flex items-center gap-2 overflow-hidden">
                    <button onClick={() => onBreadcrumbClick(null)} className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"><HomeIcon /></button>
                    {breadcrumbs.map((crumb, index) => (
                        <React.Fragment key={crumb.id}><span className="text-gray-400 dark:text-gray-500">/</span><button onClick={() => onBreadcrumbClick(crumb.id)} className="px-2 py-1 text-sm text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors truncate" title={crumb.text}>{crumb.text || <em>Untitled</em>}</button></React.Fragment>
                    ))}
                </div>
              <div className="flex items-center gap-2">
                 <button onClick={onOpenSearch} title="Quick Find (Ctrl+Shift+K)" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"><SearchIcon /></button>
                <button onClick={onGoToToday} title="Go to Today's Log (Ctrl+J)" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"><AppointmentIcon className="w-5 h-5" /></button>
                <button onClick={onToggleFavorite} title={isFavorite ? "Remove from Favorites" : "Add to Favorites"} className={`p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${!canFavorite ? 'opacity-50 cursor-not-allowed' : ''}`} disabled={!canFavorite}><StarIcon filled={isFavorite} /></button>
                <div className="flex items-center gap-1">
                    <input type="file" ref={fileInputRef} className="hidden" accept=".json" onChange={handleFileChange} />
                    <button onClick={handleImportClick} title="Import from JSON" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"><UploadIcon /></button>
                    <button onClick={onExport} title="Export to JSON" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"><DownloadIcon /></button>
                    <button onClick={onThemeToggle} title="Toggle Theme" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">{theme === 'dark' ? <SunIcon /> : <MoonIcon />}</button>
                    <button onClick={onOpenSettings} title="Settings" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"><SettingsIcon /></button>
                </div>
              </div>
            </div>
          );
      });

      // ==========================================
      // 6. BULLET ITEM & TEXT RENDERING
      // ==========================================

      const highlightText = (text, highlight) => {
          if (!text) return text;
          const regex = highlight ? new RegExp(`(${highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi') : null;
          const parts = highlight ? text.split(regex) : [text];
          return (
            <React.Fragment>
              {parts.map((part, i) => {
                  if (!part) return null;
                  const lines = part.split('\n');
                  const partWithBreaks = lines.map((line, j) => <React.Fragment key={j}>{line}{j < lines.length - 1 && <br />}</React.Fragment>);
                  if (highlight && part.toLowerCase() === highlight.toLowerCase()) return <span key={i} className="bg-yellow-300/80 dark:bg-yellow-500/50 text-black dark:text-white rounded-sm">{partWithBreaks}</span>;
                  return <React.Fragment key={i}>{partWithBreaks}</React.Fragment>;
              })}
            </React.Fragment>
          );
      };

      const renderRichTextContent = (text, highlight, onLinkClick, options = {}) => {
          const { renderTagsOnly = false } = options;
          if (!text) return null;
          if (renderTagsOnly) {
              const tagRegex = /(#\w+)/g;
              const parts = text.split(tagRegex);
              return <React.Fragment>{parts.map((part, index) => (part.startsWith('#') && /#\w+/.test(part) ? <span key={index} className="tag-span">{part}</span> : <span key={index}>{part}</span>))}</React.Fragment>;
          }
          const combinedRegex = /(#\w+|\[\[.*?\]\]|\[[^\]]+?\]\([^)]+?\)|\b(?:https?|ftp):\/\/[^\s/$.?#].[^\s]*|\bwww\.[^\s/$.?#].[^\s]*|[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g;
          const parts = text.split(combinedRegex);
          return (
            <React.Fragment>
              {parts.map((part, index) => {
                  if (!part) return null;
                  if (part.startsWith('#') && /#\w+/.test(part)) return <span key={index} className="tag-span">{highlightText(part, highlight)}</span>;
                  if (part.startsWith('[[') && part.endsWith(']]')) { const linkText = part.slice(2, -2); return <button key={index} onClick={(e) => { e.stopPropagation(); onLinkClick(linkText); }} className="bg-[var(--main-color)]/20 hover:bg-[var(--main-color)]/30 text-[var(--main-color)] rounded-sm px-1 py-0 mx-px transition-colors" title={`Go to: ${linkText}`}>{highlightText(linkText, highlight)}</button>; }
                  const mdLinkMatch = part.match(/^\[([^\]]+)\]\(([^)]+)\)$/);
                  if (mdLinkMatch) { const [, text, url] = mdLinkMatch; let href = url.trim(); if (!/^(https?|ftp|mailto):/i.test(href)) href = `https://${href}`; return <a key={index} href={href} target="_blank" rel="noopener noreferrer" title={`Opens: ${href}`} onClick={(e) => e.stopPropagation()} className="text-[var(--main-color)] underline decoration-dotted hover:decoration-solid">{highlightText(text, highlight)}</a>; }
                  if (/^(https?|ftp):\/\//.test(part) || part.startsWith('www.')) { const href = part.startsWith('www.') ? `https://${part}` : part; return <a key={index} href={href} target="_blank" rel="noopener noreferrer" title={`Opens: ${href}`} onClick={(e) => e.stopPropagation()} className="text-[var(--main-color)] underline decoration-dotted hover:decoration-solid">{highlightText(part, highlight)}</a>; }
                  if (/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(part)) return <a key={index} href={`mailto:${part}`} title={`Email: ${part}`} onClick={(e) => e.stopPropagation()} className="text-[var(--main-color)] underline decoration-dotted hover:decoration-solid">{highlightText(part, highlight)}</a>;
                  return highlightText(part, highlight);
              })}
            </React.Fragment>
          );
      };

      const BulletItemImpl = ({ bullet, level, onUpdate, onAddSibling, onDelete, onIndent, onOutdent, onFocusChange, onZoom, onFocusMove, onFocusParent, onFocusChild, onFoldAll, onMoveBullet, currentFocusId, focusPosition, focusMode, searchQuery, onLinkClick, onTriggerLinkPopup, onCloseLinkPopup, onLinkNavigate, onLinkSelect, isLinkPopupOpen, linkPopupTargetId, onTriggerTagPopup, onCloseTagPopup, onTagNavigate, onTagSelect, isTagPopupOpen, tagPopupTargetId, isJournalRoot, onNavigateTo, onMerge }) => {
        const [isEditing, setIsEditing] = useState(false);
        const textInputRef = useRef(null);
        const viewRef = useRef(null);
        const isFocused = currentFocusId === bullet.id;
        
        useEffect(() => {
          if (isFocused) {
            setIsEditing(focusMode === 'edit');
          } else {
            setIsEditing(false);
            onCloseLinkPopup();
            onCloseTagPopup();
          }
        }, [isFocused, focusMode, onCloseLinkPopup, onCloseTagPopup]);

        // Handle Focus
        useEffect(() => {
            if (isFocused) {
                if (isEditing && textInputRef.current) {
                    textInputRef.current.focus();
                    if (focusPosition === 'start') {
                        textInputRef.current.setSelectionRange(0, 0);
                    } else if (focusPosition === 'end') {
                        const len = textInputRef.current.value.length;
                        textInputRef.current.setSelectionRange(len, len);
                    } else if (typeof focusPosition === 'number') {
                        textInputRef.current.setSelectionRange(focusPosition, focusPosition);
                    }
                    textInputRef.current.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else if (!isEditing && viewRef.current) {
                    // Ensure focus on the view element when in view mode using requestAnimationFrame for reliability
                    requestAnimationFrame(() => {
                        viewRef.current?.focus();
                    });
                }
            }
        }, [isFocused, isEditing, focusPosition]);

        useEffect(() => { if (isEditing && textInputRef.current) { textInputRef.current.style.height = 'auto'; textInputRef.current.style.height = `${textInputRef.current.scrollHeight}px`; } }, [isEditing, bullet.text]);

        const hasChildren = bullet.children.length > 0;
        const handleLinkSelection = useCallback((selectedBullet) => {
          const input = textInputRef.current;
          if (!input) return;
          const text = input.value;
          const cursor = input.selectionStart ?? text.length;
          const textBeforeCursor = text.substring(0, cursor);
          const lastOpen = textBeforeCursor.lastIndexOf('[[');
          if (lastOpen !== -1) {
              const newText = text.substring(0, lastOpen) + `[[${selectedBullet.text}]]` + text.substring(cursor);
              onUpdate(bullet.id, { text: newText });
              onCloseLinkPopup();
              setTimeout(() => { const newCursorPos = (text.substring(0, lastOpen) + `[[${selectedBullet.text}]]`).length; input.focus(); input.setSelectionRange(newCursorPos, newCursorPos); }, 0);
          }
        }, [bullet.id, onUpdate, onCloseLinkPopup]);
        
        const handleTagSelection = useCallback((selectedTag) => {
          const input = textInputRef.current;
          if (!input) return;
          const text = input.value;
          const cursor = input.selectionStart ?? text.length;
          const textBeforeCursor = text.substring(0, cursor);
          const match = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);
          if (match) {
              const startIndex = match.index + (match[0].startsWith(' ') ? 1 : 0);
              const newText = text.substring(0, startIndex) + selectedTag + ' ' + text.substring(cursor);
              onUpdate(bullet.id, { text: newText });
              onCloseTagPopup();
              setTimeout(() => { const newCursorPos = startIndex + selectedTag.length + 1; input.focus(); input.setSelectionRange(newCursorPos, newCursorPos); }, 0);
          }
        }, [bullet.id, onUpdate, onCloseTagPopup]);
        
        const handleTextChange = (e) => {
          const text = e.target.value;
          const cursor = e.target.selectionStart;
          onUpdate(bullet.id, { text });
          const textBeforeCursor = text.substring(0, cursor ?? 0);
          const lastOpenBracket = textBeforeCursor.lastIndexOf('[[');
          if (lastOpenBracket !== -1 && textBeforeCursor.lastIndexOf(']]') < lastOpenBracket) {
            const query = textBeforeCursor.substring(lastOpenBracket + 2);
            onTriggerLinkPopup(bullet.id, query, textInputRef, handleLinkSelection);
            return;
          }
          const tagMatch = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);
          if (tagMatch) { onTriggerTagPopup(bullet.id, tagMatch[1], textInputRef, handleTagSelection); return; }
          onCloseLinkPopup(); onCloseTagPopup();
        };

        const handleViewKeyDown = (e) => {
            if (bullet.isReadOnly) return;
            
            if (e.key === 'Enter') {
                e.preventDefault();
                onFocusChange(bullet.id, 'end', 'edit');
                return;
            }
            
            if (e.key === 'ArrowUp') {
                if (e.altKey) {
                    e.preventDefault();
                    onMoveBullet(bullet.id, 'up');
                } else if (e.ctrlKey || e.metaKey) {
                    return; // Allow bubbling to handle global Zoom Out
                } else {
                    e.preventDefault();
                    onFocusMove('up', undefined, 'view');
                }
                return;
            }
            
            if (e.key === 'ArrowDown') {
                if (e.altKey) {
                    e.preventDefault();
                    onMoveBullet(bullet.id, 'down');
                } else if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    onZoom(bullet.id);
                } else {
                    e.preventDefault();
                    onFocusMove('down', undefined, 'view');
                }
                return;
            }

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                if (e.ctrlKey || e.metaKey) {
                    // Ctrl+Left: Recursively fold bullet and all sub bullets
                    onFoldAll(bullet.id, true, true);
                } else {
                    // Left Arrow:
                    // 1. If has children AND is expanded -> Collapse (Fold)
                    // 2. Otherwise -> Select parent
                    if (bullet.children.length > 0 && !bullet.isCollapsed) {
                        onUpdate(bullet.id, { isCollapsed: true });
                    } else {
                        onFocusParent(bullet.id);
                    }
                }
                return;
            }

            if (e.key === 'ArrowRight') {
                e.preventDefault();
                if (e.ctrlKey || e.metaKey) {
                    // Ctrl+Right: Recursively unfold bullet and all sub bullets
                    onFoldAll(bullet.id, false, true);
                } else {
                    // Right Arrow:
                    // 1. If has children AND is collapsed -> Expand (Unfold)
                    // 2. Otherwise (expanded or no children) -> Select first child (if exists)
                    if (bullet.children.length > 0 && bullet.isCollapsed) {
                        onUpdate(bullet.id, { isCollapsed: false });
                    } else {
                        onFocusChild(bullet.id);
                    }
                }
                return;
            }
            
            // Backspace: Delete selected bullet and all sub-bullets
            if (e.key === 'Backspace') {
                e.preventDefault();
                onDelete(bullet.id);
            }
        };

        const handleEditKeyDown = (e) => {
          const input = e.target;
          if (bullet.isReadOnly) return;
          if (isTagPopupOpen && tagPopupTargetId === bullet.id) {
              let handled = true;
              switch (e.key) {
                  case 'ArrowUp': onTagNavigate('up'); break;
                  case 'ArrowDown': onTagNavigate('down'); break;
                  case 'Tab': onTagSelect(handleTagSelection); break;
                  case 'Escape': onCloseTagPopup(); break;
                  default: handled = false;
              }
              if (handled) { e.preventDefault(); return; }
          }
          if (isLinkPopupOpen && linkPopupTargetId === bullet.id) {
              let handled = true;
              switch (e.key) {
                  case 'ArrowUp': onLinkNavigate('up'); break;
                  case 'ArrowDown': onLinkNavigate('down'); break;
                  case 'Enter': onLinkSelect(handleLinkSelection); break;
                  case 'Tab': onLinkSelect(handleLinkSelection); break;
                  case 'Escape': { onCloseLinkPopup(); const text = input.value; const cursor = input.selectionStart ?? text.length; const textBeforeCursor = text.substring(0, cursor); const lastOpen = textBeforeCursor.lastIndexOf('[['); if (lastOpen !== -1 && textBeforeCursor.lastIndexOf(']]') < lastOpen) { const newText = text.substring(0, lastOpen) + text.substring(cursor); onUpdate(bullet.id, { text: newText }); setTimeout(() => { if(textInputRef.current) { textInputRef.current.focus(); textInputRef.current.setSelectionRange(lastOpen, lastOpen); } }, 0); } break; }
                  default: handled = false;
              }
              if (handled) { e.preventDefault(); return; }
          }
          if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) {
              e.preventDefault();
              const start = input.selectionStart; const end = input.selectionEnd; const text = input.value; const selectedText = text.substring(start, end);
              let newText, newCursorPosStart, newCursorPosEnd;
              if (selectedText) { newText = `${text.substring(0, start)}[${selectedText}]()${text.substring(end)}`; newCursorPosStart = newCursorPosEnd = start + selectedText.length + 3; }
              else { newText = `${text.substring(0, start)}[link text]()${text.substring(end)}`; newCursorPosStart = start + 1; newCursorPosEnd = start + 1 + 'link text'.length; }
              onUpdate(bullet.id, { text: newText });
              setTimeout(() => { if (textInputRef.current) { textInputRef.current.focus(); textInputRef.current.setSelectionRange(newCursorPosStart, newCursorPosEnd); } }, 0);
              return;
          }
          if (e.altKey) {
              if (e.key === 'ArrowUp') { e.preventDefault(); onMoveBullet(bullet.id, 'up'); return; }
              if (e.key === 'ArrowDown') { e.preventDefault(); onMoveBullet(bullet.id, 'down'); return; }
          }
          
          switch (e.key) {
            case 'Escape': e.preventDefault(); onFocusChange(bullet.id, undefined, 'view'); break;
            case 'Enter': e.preventDefault(); if (e.shiftKey) { const { value, selectionStart, selectionEnd } = input; const newValue = value.substring(0, selectionStart) + '\n' + value.substring(selectionEnd); onUpdate(bullet.id, { text: newValue }); setTimeout(() => { if (textInputRef.current) { const newCursorPos = selectionStart + 1; textInputRef.current.focus(); textInputRef.current.setSelectionRange(newCursorPos, newCursorPos); } }, 0); } else { const { value, selectionStart } = input; const textBeforeCursor = value.substring(0, selectionStart); const textAfterCursor = value.substring(selectionStart); onUpdate(bullet.id, { text: textBeforeCursor }); onAddSibling(bullet.id, textAfterCursor); } break;
            case 'Tab': e.preventDefault(); if (e.shiftKey) onOutdent(bullet.id); else onIndent(bullet.id); break;
            case 'Backspace': if (input.selectionStart === 0 && input.selectionEnd === 0) { e.preventDefault(); onMerge(bullet.id); } break;
            case 'ArrowUp': if (e.ctrlKey) { e.preventDefault(); onMoveBullet(bullet.id, 'up'); } break;
            case 'ArrowDown': if (e.ctrlKey) { e.preventDefault(); onMoveBullet(bullet.id, 'down'); } break;
          }
        };

        const toggleCollapse = () => { if (hasChildren) onUpdate(bullet.id, { isCollapsed: !bullet.isCollapsed }); };
        const matchesSearch = (b, q) => { if (!q) return true; const query = q.toLowerCase(); const textMatch = b.text.toLowerCase().includes(query); const childrenMatch = b.children.some(child => matchesSearch(child, q)); return textMatch || childrenMatch; };
        
        const renderedRichText = useMemo(() => renderRichTextContent(bullet.text, searchQuery, onLinkClick), [bullet.text, searchQuery, onLinkClick]);
        const renderedRichTextSimple = useMemo(() => renderRichTextContent(bullet.text, undefined, () => {}, { renderTagsOnly: true }), [bullet.text]);
        
        if (searchQuery && !matchesSearch(bullet, searchQuery)) return null;
        
        const handleViewClick = (e) => {
            const target = e.target;
            if (target.tagName === 'SPAN' && (target.innerText.startsWith('[[') || target.innerText.startsWith('#'))) {
                onLinkClick(target.innerText.replace(/[\[\]]/g, ''));
                return;
            }
            if (!isEditing && !bullet.isReadOnly) {
                onFocusChange(bullet.id, undefined, 'edit');
            }
        };

        const renderBulletIcon = () => isJournalRoot ? <AppointmentIcon className="w-4 h-4" /> : <CircleIcon className="w-2 h-2" color='var(--main-color)' />;
        
        return (
          <div className="flex flex-col group">
              <div className={`flex items-start py-1 rounded transition-colors ${isFocused && !isEditing ? 'bg-blue-50 dark:bg-gray-800' : ''}`}>
                  <div style={{ marginLeft: `${level * 1.5}em` }} className="flex-shrink-0 flex items-center h-[1.5em] text-[var(--main-color)]">
                      <button onClick={toggleCollapse} onMouseDown={(e) => e.preventDefault()} tabIndex={-1} className={`transition-opacity duration-150 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300 ${hasChildren ? 'opacity-100 cursor-pointer' : 'opacity-0 cursor-default'}`} aria-label={bullet.isCollapsed ? 'Expand' : 'Collapse'}>
                          {bullet.isCollapsed ? <ChevronRightIcon /> : <ChevronDownIcon />}
                      </button>
                      <button onClick={() => onZoom(bullet.id)} onMouseDown={(e) => e.preventDefault()} tabIndex={-1} className="ml-1 w-[1.5em] h-[1.5em] flex items-center justify-center transition-colors" aria-label="Zoom in">{renderBulletIcon()}</button>
                  </div>
                  <div className="flex-grow ml-2">
                      <div className="flex items-center">
                          <div className="flex-grow">
                              {isEditing ? (
                                  <div className="relative">
                                      <div className="absolute top-0 left-0 w-full h-full pointer-events-none leading-[1.5] whitespace-pre-wrap break-words" aria-hidden="true">{renderedRichTextSimple}</div>
                                      <textarea ref={textInputRef} value={bullet.text} onChange={handleTextChange} onKeyDown={handleEditKeyDown} readOnly={bullet.isReadOnly} className="w-full bg-transparent outline-none text-transparent caret-gray-800 dark:caret-gray-200 resize-none overflow-hidden leading-[1.5]" rows={1} aria-label="Edit item" />
                                  </div>
                              ) : (
                                  <div 
                                      ref={viewRef} 
                                      tabIndex={0} 
                                      onClick={handleViewClick} 
                                      onKeyDown={handleViewKeyDown} 
                                      className={`w-full min-h-[1.5em] leading-[1.5] break-words outline-none ${isFocused ? 'ring-2 ring-opacity-20 ring-[var(--main-color)] rounded-sm' : ''} ${bullet.isReadOnly ? 'cursor-pointer' : 'cursor-text'} text-gray-800 dark:text-gray-200`}
                                  >
                                      {bullet.text ? renderedRichText : <span className="text-gray-400 dark:text-gray-500">...</span>}
                                  </div>
                              )}
                          </div>
                      </div>
                  </div>
              </div>
            {!bullet.isCollapsed && hasChildren && (
              <div className="border-l border-gray-300 dark:border-gray-700/50">
                {bullet.children.map((child) => (
                  <BulletItem key={child.id} bullet={child} level={level + 1} onUpdate={onUpdate} onAddSibling={onAddSibling} onDelete={onDelete} onIndent={onIndent} onOutdent={onOutdent} onFocusChange={onFocusChange} onZoom={onZoom} onFocusMove={onFocusMove} onFocusParent={onFocusParent} onFocusChild={onFocusChild} onFoldAll={onFoldAll} onMoveBullet={onMoveBullet} currentFocusId={currentFocusId} focusPosition={focusPosition} focusMode={focusMode} searchQuery={searchQuery} onLinkClick={onLinkClick} onTriggerLinkPopup={onTriggerLinkPopup} onCloseLinkPopup={onCloseLinkPopup} onLinkNavigate={onLinkNavigate} onLinkSelect={onLinkSelect} isLinkPopupOpen={isLinkPopupOpen} linkPopupTargetId={linkPopupTargetId} onTriggerTagPopup={onTriggerTagPopup} onCloseTagPopup={onCloseTagPopup} onTagNavigate={onTagNavigate} onTagSelect={onTagSelect} isTagPopupOpen={isTagPopupOpen} tagPopupTargetId={tagPopupTargetId} isJournalRoot={false} onNavigateTo={onNavigateTo} onMerge={onMerge} />
                ))}
              </div>
            )}
          </div>
        );
      };

      const BulletItem = React.memo(BulletItemImpl);

      // ==========================================
      // 7. APP LOGIC
      // ==========================================

      // DB Setup
      class JaroetDatabase extends Dexie {
          constructor() {
              super("JaroetOutlinerDB");
              this.version(1).stores({ keyValuePairs: 'key' });
              this.keyValuePairs = this.table('keyValuePairs');
          }
      }
      const db = new JaroetDatabase();

      const DAILY_LOG_ROOT_TEXT = 'Daily Log';
      const initialData = [
        { id: 'journal-root', text: DAILY_LOG_ROOT_TEXT, children: [], isCollapsed: true },
        { id: 'help-info', text: 'For help and documentation, import the jr_help-documentation.json file.', children: [], isCollapsed: false }
      ];

      const createNewBullet = (text = '') => { const now = Date.now(); return { id: crypto.randomUUID(), text, children: [], isCollapsed: false, createdAt: now, updatedAt: now }; };
      const migrateBullets = (nodes) => { if (!Array.isArray(nodes)) return []; const now = Date.now(); return nodes.map(node => ({ ...node, createdAt: node.createdAt || now, updatedAt: node.updatedAt || now, children: migrateBullets(node.children || []) })); };
      const regenerateIds = (nodes) => { if (!Array.isArray(nodes)) return []; return nodes.map(node => ({ ...node, id: crypto.randomUUID(), children: regenerateIds(node.children || []) })); };
      
      const mapBullets = (nodes, callback) => {
          let changed = false;
          const newNodes = nodes.map(node => {
              const newNode = callback(node);
              const newChildren = mapBullets(newNode.children, callback);
              if (newNode === node && newChildren === node.children) return node;
              changed = true;
              return { ...newNode, children: newChildren };
          });
          return changed ? newNodes : nodes;
      };

      const FONT_LIST = ['Arial', 'Verdana', 'Helvetica', 'Tahoma', 'Trebuchet MS', 'Times New Roman', 'Georgia', 'Garamond', 'Courier New', 'Brush Script MT', 'sans-serif', 'serif', 'monospace'];
      
      const SettingsModal = ({ isOpen, onClose, onSave, currentSettings, onClearData }) => {
          const [settings, setSettings] = useState(currentSettings);
          useEffect(() => setSettings(currentSettings), [isOpen, currentSettings]);
          const handleSave = () => { onSave(settings); onClose(); };
          const handleInputChange = (e) => { const { name, value } = e.target; setSettings(prev => ({...prev, [name]: value })); };
          const handleFontSizeChange = (e) => setSettings(prev => ({...prev, fontSize: parseInt(e.target.value, 10) }));
          if (!isOpen) return null;
          return (
              <div className="fixed inset-0 bg-black/60 z-30 flex justify-center items-center" onClick={onClose}>
                  <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md" onClick={e => e.stopPropagation()}>
                      <h2 className="p-4 text-lg font-semibold border-b border-gray-200 dark:border-gray-700">Settings</h2>
                      <div className="p-4 space-y-4">
                          <div><label htmlFor="fileName" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">File Name</label><input type="text" id="fileName" name="fileName" value={settings.fileName} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]"/></div>
                          <div><label htmlFor="mainColor" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Main Color</label><input type="color" id="mainColor" name="mainColor" value={settings.mainColor} onChange={handleInputChange} className="w-full h-10 p-1 bg-gray-100 dark:bg-gray-700 rounded-md cursor-pointer"/></div>
                          <div><label htmlFor="fontFamily" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Font</label><select id="fontFamily" name="fontFamily" value={settings.fontFamily} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]">{FONT_LIST.map(font => <option key={font} value={font}>{font}</option>)}</select></div>
                          <div><label htmlFor="fontSize" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Font Size ({settings.fontSize}px)</label><input type="range" id="fontSize" name="fontSize" min="12" max="24" value={settings.fontSize} onChange={handleFontSizeChange} className="w-full"/></div>
                          <div className="pt-4 border-t border-gray-200 dark:border-gray-700">
                               <h3 className="text-sm font-medium text-red-600 dark:text-red-400 mb-2">Data Management</h3>
                               <button onClick={onClearData} className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-md transition-colors w-full justify-center"><TrashIcon className="w-4 h-4" />Reset Application Data</button>
                              <p className="mt-1 text-xs text-gray-500 dark:text-gray-400 text-center">Deletes all local data and restores the default template.</p>
                          </div>
                      </div>
                      <div className="p-4 flex justify-end gap-2 border-t border-gray-200 dark:border-gray-700">
                          <button onClick={onClose} className="px-4 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-600 dark:hover:bg-gray-500 dark:text-white">Cancel</button>
                          <button onClick={handleSave} className="px-4 py-2 rounded-md bg-[var(--main-color)] text-white hover:opacity-90">Save</button>
                      </div>
                  </div>
              </div>
          );
      };

      const App = () => {
          const [bullets, setBullets] = useState(initialData);
          const [zoomedBulletId, setZoomedBulletId] = useState(null);
          const [searchQuery, setSearchQuery] = useState('');
          const [focusOptions, setFocusOptions] = useState({ id: null, position: 'end', mode: 'view' });
          const isInitialFocusSet = useRef(false);
          const linkPopupRef = useRef(null);
          const tagPopupRef = useRef(null);
          const [isSearchModalOpen, setIsSearchModalOpen] = useState(false);
          const [linkSelectionHandler, setLinkSelectionHandler] = useState({ handler: null });
          const [tagSelectionHandler, setTagSelectionHandler] = useState({ handler: null });
          const prevFocusId = useRef(null);
          const dataLoadedRef = useRef(false);
          const prevCoreDataRef = useRef(null);
          const [theme, setTheme] = useState('dark');
          const focusBeforeModalRef = useRef(null);
          const { toasts, addToast, removeToast } = useToast();
          const [settings, setSettings] = useState({ mainColor: '#60a5fa', fileName: 'My Outline', fontFamily: 'sans-serif', fontSize: 16 });
          const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);
          const [pendingImportData, setPendingImportData] = useState(null);
          const [isImportModalOpen, setIsImportModalOpen] = useState(false);
          const [linkPopupState, setLinkPopupState] = useState({ isOpen: false, targetId: null, query: '', position: { top: 0, left: 0 }, suggestions: [], selectedIndex: 0 });
          const [tagPopupState, setTagPopupState] = useState({ isOpen: false, targetId: null, query: '', position: { top: 0, left: 0 }, suggestions: [], selectedIndex: 0 });

          // Sidebar State
          const [isSidebarOpen, setIsSidebarOpen] = useState(false);
          const [recentBullets, setRecentBullets] = useState([]);
          const [favoriteBullets, setFavoriteBullets] = useState([]);

          const currentFocusId = focusOptions.id;
          const focusPosition = focusOptions.position;
          const focusMode = focusOptions.mode;
          const handleFocusChange = useCallback((id, position = 'end', mode = 'view') => setFocusOptions({ id, position, mode }), []);

          const getCoreDataString = useCallback((nodes) => {
              const removeUiState = (b) => ({ id: b.id, text: b.text, children: b.children.map(removeUiState), originalId: b.originalId, createdAt: b.createdAt, updatedAt: b.updatedAt, isFavorite: b.isFavorite });
              const coreBullets = nodes.map(removeUiState);
              return JSON.stringify(coreBullets);
          }, []);

          const handleThemeToggle = useCallback(() => {
              const newTheme = theme === 'light' ? 'dark' : 'light';
              setTheme(newTheme);
              db.keyValuePairs.put({ key: 'theme', value: newTheme });
              addToast(`Switched to ${newTheme} mode`, 'info');
          }, [theme, addToast]);

          useEffect(() => { window.document.documentElement.classList.toggle('dark', theme === 'dark'); }, [theme]);

          // Helper to update recent list in-memory
          const updateRecentList = useCallback((id, text, updatedAt) => {
              setRecentBullets(prev => {
                  const newList = prev.filter(item => item.id !== id);
                  let itemText = text;
                  if (itemText === undefined) {
                      const existing = prev.find(i => i.id === id);
                      if (existing) itemText = existing.text;
                      else return prev;
                  }
                  newList.unshift({ id, text: itemText, updatedAt });
                  return newList.slice(0, 12);
              });
          }, []);

          const removeFromRecentList = useCallback((id) => {
              setRecentBullets(prev => prev.filter(item => item.id !== id));
              setFavoriteBullets(prev => prev.filter(item => item.id !== id));
          }, []);

          useEffect(() => {
              const loadData = async () => {
                  const savedThemeEntry = await db.keyValuePairs.get('theme');
                  const savedTheme = savedThemeEntry?.value;
                  if (savedTheme && (savedTheme === 'light' || savedTheme === 'dark')) setTheme(savedTheme);
                  
                  try {
                    const savedSidebar = await db.keyValuePairs.get('isSidebarOpen');
                    if (savedSidebar !== undefined) setIsSidebarOpen(savedSidebar.value);
                  } catch (e) { console.error("Failed to load sidebar state", e); }

                  // Load Recents & Favorites from DB directly
                  try {
                    const savedRecents = await db.keyValuePairs.get('recentBullets');
                    if (savedRecents?.value) setRecentBullets(savedRecents.value);
                    
                    const savedFavorites = await db.keyValuePairs.get('favoriteBullets');
                    if (savedFavorites?.value) setFavoriteBullets(savedFavorites.value);
                  } catch (e) { console.error("Failed to load sidebar lists", e); }

                  let loadedSettings;
                  const defaultSettings = { mainColor: '#60a5fa', fileName: 'My Outline', fontFamily: 'sans-serif', fontSize: 16 };
                  try {
                      const savedSettingsEntry = await db.keyValuePairs.get('settings');
                      loadedSettings = { ...defaultSettings, ...(savedSettingsEntry?.value || {}) };
                      setSettings(loadedSettings);
                  } catch (error) { loadedSettings = defaultSettings; }

                  let localBullets = null;
                  try {
                      const savedDataEntry = await db.keyValuePairs.get('bullets');
                      if (savedDataEntry?.value && Array.isArray(savedDataEntry.value)) localBullets = savedDataEntry.value;
                  } catch(e) { console.error("Failed to parse local data", e); }
                  
                  let initialLoadData = localBullets || initialData;
                  initialLoadData = migrateBullets(initialLoadData);
                  setBullets(initialLoadData);
                  prevCoreDataRef.current = getCoreDataString(initialLoadData);
                  setZoomedBulletId(null);
                  isInitialFocusSet.current = false;
                  dataLoadedRef.current = true;
              };
              loadData();
          }, [getCoreDataString]);

          // Persist data
          useEffect(() => {
              if (!dataLoadedRef.current) return;
              db.keyValuePairs.put({ key: 'settings', value: settings });
              document.title = `${settings.fileName || 'Untitled'} - JaRoet Outliner`;
              const root = document.documentElement;
              root.style.setProperty('--main-color', settings.mainColor);
              root.style.setProperty('--font-family', settings.fontFamily);
              root.style.setProperty('--font-size', `${settings.fontSize}px`);
              db.keyValuePairs.put({ key: 'bullets', value: bullets });
              const currentCoreData = getCoreDataString(bullets);
              if (currentCoreData !== prevCoreDataRef.current) prevCoreDataRef.current = currentCoreData;
          }, [settings, bullets, getCoreDataString]);

          // Save Recents and Favorites separately when they change
          useEffect(() => { if (!dataLoadedRef.current) return; db.keyValuePairs.put({ key: 'recentBullets', value: recentBullets }); }, [recentBullets]);
          useEffect(() => { if (!dataLoadedRef.current) return; db.keyValuePairs.put({ key: 'favoriteBullets', value: favoriteBullets }); }, [favoriteBullets]);

          const findBulletAndParent = useCallback((id, nodes, parent = null) => {
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              if (node.id === id) return { node, parent, siblings: nodes, index: i };
              const found = findBulletAndParent(id, node.children, node);
              if (found) return found;
            }
            return null;
          }, []);

          useEffect(() => {
              const currentId = focusOptions.id; const prevId = prevFocusId.current;
              if (prevId && prevId !== currentId) {
                  const found = findBulletAndParent(prevId, bullets);
                  if (found && !found.node.isReadOnly && found.node.text === '' && found.node.children.length === 0) {
                      const newBullets = structuredClone(bullets);
                      const foundAgain = findBulletAndParent(prevId, newBullets);
                      if (foundAgain) { 
                          foundAgain.siblings.splice(foundAgain.index, 1); 
                          setBullets(newBullets); 
                          removeFromRecentList(prevId);
                      }
                  }
              }
              prevFocusId.current = currentId;
          }, [focusOptions.id, bullets, findBulletAndParent, removeFromRecentList]);

          const breadcrumbs = useMemo(() => {
              if (!zoomedBulletId) return [];
              const path = [];
              const findPath = (nodes, currentPath) => {
                  for (const node of nodes) {
                      const newPath = [...currentPath, node];
                      if (node.id === zoomedBulletId) { path.push(...newPath); return true; }
                      if (findPath(node.children, newPath)) return true;
                  }
                  return false;
              };
              findPath(bullets, []);
              return path;
          }, [bullets, zoomedBulletId]);

          const handleNavigate = useCallback((bulletId) => {
              setBullets(prev => mapBullets(prev, b => {
                   if (b.id === bulletId) return { ...b, isCollapsed: false };
                   return b;
              }));

              const path = [];
              const findPath = (nodes, currentPath) => {
                  for (const node of nodes) {
                      const newPath = [...currentPath, node];
                      if (node.id === bulletId) { path.push(...newPath); return true; }
                      if (findPath(node.children, newPath)) return true;
                  }
                  return false;
              };
              findPath(bullets, []);
              if (path.length > 0) {
                  const parent = path.length > 1 ? path[path.length - 2] : null;
                  setZoomedBulletId(parent ? parent.id : null);
                  setIsSearchModalOpen(false);
                  setSearchQuery('');
                  setTimeout(() => handleFocusChange(bulletId, 'end', 'view'), 0);
              }
          }, [bullets, handleFocusChange]);

          const displayedBullets = useMemo(() => {
              if (!zoomedBulletId) return bullets;
              const findZoomed = (nodes) => { for (const node of nodes) { if (node.id === zoomedBulletId) return node; const found = findZoomed(node.children); if (found) return found; } return null; }
              const zoomedNode = findZoomed(bullets);
              return zoomedNode ? zoomedNode.children : [];
          }, [bullets, zoomedBulletId]);
          
          // Favorites Logic
          const targetFavoriteId = currentFocusId || zoomedBulletId;

          const isTargetFavorite = useMemo(() => {
              if (!targetFavoriteId) return false;
              const findBullet = (nodes) => { for (const node of nodes) { if (node.id === targetFavoriteId) return node; const found = findBullet(node.children); if (found) return found; } return null; }
              const node = findBullet(bullets);
              return node?.isFavorite || false;
          }, [bullets, targetFavoriteId]);

          const handleToggleFavorite = useCallback(() => {
              if (!targetFavoriteId) return;
              
              setBullets(prev => {
                  let isNowFav = false;
                  let targetText = '';
                  const newBullets = mapBullets(prev, b => {
                      if (b.id === targetFavoriteId) {
                          isNowFav = !b.isFavorite;
                          targetText = b.text;
                          return { ...b, isFavorite: isNowFav };
                      }
                      return b;
                  });
                  setFavoriteBullets(currentFavs => {
                      if (isNowFav) {
                        if (currentFavs.some(f => f.id === targetFavoriteId)) return currentFavs;
                        return [...currentFavs, { id: targetFavoriteId, text: targetText }];
                      }
                      else return currentFavs.filter(f => f.id !== targetFavoriteId);
                  });
                  if (isNowFav) addToast('Added to favorites', 'success');
                  else addToast('Removed from favorites', 'info');
                  return newBullets;
              });
          }, [targetFavoriteId, addToast]);

          const visibleBulletIds = useMemo(() => {
              const getVisibleIds = (nodes) => { let ids = []; for (const node of nodes) { ids.push(node.id); if (!node.isCollapsed && node.children.length > 0) ids = ids.concat(getVisibleIds(node.children)); } return ids; };
              return getVisibleIds(displayedBullets);
          }, [displayedBullets]);

          const bulletsRef = useRef(bullets); const visibleBulletIdsRef = useRef(visibleBulletIds); const zoomedBulletIdRef = useRef(zoomedBulletId); const focusOptionsRef = useRef(focusOptions); const breadcrumbsRef = useRef(breadcrumbs);
          useEffect(() => { bulletsRef.current = bullets; }, [bullets]); useEffect(() => { visibleBulletIdsRef.current = visibleBulletIds; }, [visibleBulletIds]); useEffect(() => { zoomedBulletIdRef.current = zoomedBulletId; }, [zoomedBulletId]); useEffect(() => { focusOptionsRef.current = focusOptions; }, [focusOptions]); useEffect(() => { breadcrumbsRef.current = breadcrumbs; }, [breadcrumbs]);

          useEffect(() => { if (!isInitialFocusSet.current && visibleBulletIds.length > 0) { handleFocusChange(visibleBulletIds[0], 'end', 'view'); isInitialFocusSet.current = true; } }, [visibleBulletIds, handleFocusChange]);

          const handleZoom = useCallback((id) => {
              const currentBullets = bulletsRef.current; const oldZoomedBulletId = zoomedBulletIdRef.current; const currentBreadcrumbs = breadcrumbsRef.current;
              const isZoomingOut = (id === null && oldZoomedBulletId !== null) || (id !== null && currentBreadcrumbs.some(b => b.id === id));
              if (id === null) {
                  setZoomedBulletId(null);
                  if (oldZoomedBulletId) {
                      setTimeout(() => handleFocusChange(oldZoomedBulletId, 'end', 'view'), 0);
                  } else {
                      const getVisibleIds = (nodes) => { let ids = []; for (const node of nodes) { ids.push(node.id); if (!node.isCollapsed && node.children.length > 0) ids = ids.concat(getVisibleIds(node.children)); } return ids; };
                      const rootVisibleIds = getVisibleIds(currentBullets);
                      if (rootVisibleIds.length > 0) handleFocusChange(rootVisibleIds[0], 'end', 'view');
                  }
                  return;
              }
              const find = (nodes) => { for(const node of nodes) { if (node.id === id) return node; const f = find(node.children); if (f) return f; } return null; };
              const bulletToZoom = find(currentBullets);
              if (bulletToZoom && bulletToZoom.children.length === 0 && !bulletToZoom.isReadOnly) {
                  const newBullet = createNewBullet();
                  setBullets(prevBullets => { 
                      const newBullets = structuredClone(prevBullets); 
                      const found = findBulletAndParent(id, newBullets); 
                      if (found) { 
                          found.node.children.push(newBullet); 
                          found.node.isCollapsed = false; 
                          return newBullets; 
                      } 
                      return prevBullets; 
                  });
                  setZoomedBulletId(id);
                  setTimeout(() => handleFocusChange(newBullet.id, 'start', 'edit'), 0);
                  updateRecentList(newBullet.id, newBullet.text, newBullet.updatedAt || Date.now());
              } else if (bulletToZoom) {
                  setZoomedBulletId(id);
                  if (isZoomingOut && oldZoomedBulletId) {
                       setTimeout(() => handleFocusChange(oldZoomedBulletId, 'end', 'view'), 0);
                  } else if (bulletToZoom.children.length > 0) {
                       const getVisibleIds = (nodes) => { let ids = []; for (const node of nodes) { ids.push(node.id); if (!node.isCollapsed && node.children.length > 0) ids = ids.concat(getVisibleIds(node.children)); } return ids; };
                       const visibleChildrenIds = getVisibleIds(bulletToZoom.children);
                       if (visibleChildrenIds.length > 0) handleFocusChange(visibleChildrenIds[0], 'end', 'view');
                  }
              }
          }, [handleFocusChange, findBulletAndParent, updateRecentList]);

          const handleGoToJournal = useCallback(() => {
              const now = new Date(); const year = now.getFullYear().toString(); const month = (now.getMonth() + 1).toString().padStart(2, '0'); const day = now.getDate().toString().padStart(2, '0'); const dayText = `${year}-${month}-${day}`;
              setBullets(prevBullets => {
                   const newBullets = structuredClone(prevBullets);
                   let journalNode = newBullets.find((b) => b.text === DAILY_LOG_ROOT_TEXT);
                  if (!journalNode) { journalNode = createNewBullet(DAILY_LOG_ROOT_TEXT); newBullets.unshift(journalNode); }
                  journalNode.isCollapsed = false;

                  let yearNode = journalNode.children.find((b) => b.text === year); if (!yearNode) { yearNode = createNewBullet(year); journalNode.children.push(yearNode); }
                  yearNode.isCollapsed = false;

                  let monthNode = yearNode.children.find((b) => b.text === month); if (!monthNode) { monthNode = createNewBullet(month); yearNode.children.push(monthNode); }
                  monthNode.isCollapsed = false;

                  let dayNode = monthNode.children.find((b) => b.text === dayText); if (!dayNode) { dayNode = createNewBullet(dayText); monthNode.children.push(dayNode); }
                  dayNode.isCollapsed = false;

                  setTimeout(() => {
                      setZoomedBulletId(monthNode.id);
                      setTimeout(() => handleFocusChange(dayNode.id, 'end', 'view'), 0);
                  }, 0);

                  return newBullets;
              });
              
              addToast('Opened Daily Log', 'success');
          }, [handleFocusChange, addToast]);

          const handleUpdate = useCallback((id, updates) => { 
              setBullets(prevBullets => { 
                  const found = findBulletAndParent(id, prevBullets); 
                  if (found?.node.isReadOnly) return prevBullets; 
                  const isStructuralOrContentChange = Object.keys(updates).some(key => key !== 'isCollapsed'); 
                  const newUpdatedAt = isStructuralOrContentChange ? Date.now() : undefined;

                  if (updates.text !== undefined) {
                      updateRecentList(id, updates.text, newUpdatedAt || Date.now());
                      setFavoriteBullets(prev => prev.map(f => f.id === id ? { ...f, text: updates.text } : f));
                  } else if (isStructuralOrContentChange) {
                      updateRecentList(id, undefined, newUpdatedAt || Date.now());
                  }

                  return mapBullets(prevBullets, bullet => bullet.id === id ? { ...bullet, ...updates, updatedAt: newUpdatedAt || bullet.updatedAt } : bullet); 
              }); 
          }, [findBulletAndParent, updateRecentList]);

          useEffect(() => {
              const handleGlobalKeyDown = (e) => {
                  if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'k') { e.preventDefault(); handleOpenSearch(); }
                  else if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'h') { e.preventDefault(); handleZoom(null); setBullets(prev => prev.map(b => ({ ...b, isCollapsed: true }))); setTimeout(() => { const currentBullets = bulletsRef.current; if (currentBullets.length > 0) handleFocusChange(currentBullets[0].id, 'start', 'view'); }, 10); }
                  else if (e.ctrlKey && e.key.toLowerCase() === 'j') { e.preventDefault(); handleGoToJournal(); }
                  else if (e.ctrlKey && e.key === 'ArrowUp') {
                       // Global Zoom Out
                       e.preventDefault(); 
                       const zoomedId = zoomedBulletIdRef.current; 
                       const crumbs = breadcrumbsRef.current; 
                       if (zoomedId) { 
                           const parentId = crumbs.length > 1 ? crumbs[crumbs.length - 2].id : null; 
                           handleZoom(parentId); 
                       } 
                  }
                  else if ((e.key === 'ArrowDown' || e.key === 'ArrowUp')) { const currentFocusId = focusOptionsRef.current.id; const visibleIds = visibleBulletIdsRef.current; if (!currentFocusId && visibleIds.length > 0) { const target = e.target; if(target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA') { e.preventDefault(); handleFocusChange(visibleIds[0], 'end', 'view'); } } }
              };
              window.addEventListener('keydown', handleGlobalKeyDown);
              return () => { window.removeEventListener('keydown', handleGlobalKeyDown); };
          }, [handleGoToJournal, handleZoom, handleFocusChange]);

          const handleAddSibling = useCallback((id, text = '') => {
              const newBullet = createNewBullet(text);
              setBullets(prevBullets => { 
                  const newBullets = structuredClone(prevBullets); 
                  const found = findBulletAndParent(id, newBullets); 
                  if (found) { 
                      if (found.node.isReadOnly) return prevBullets; 
                      found.siblings.splice(found.index + 1, 0, newBullet); 
                      if (found.parent) found.parent.updatedAt = Date.now(); 
                      return newBullets; 
                  } 
                  return prevBullets; 
              });
              setTimeout(() => handleFocusChange(newBullet.id, 'start', 'edit'), 0);
              updateRecentList(newBullet.id, newBullet.text, newBullet.updatedAt || Date.now());
          }, [handleFocusChange, findBulletAndParent, updateRecentList]);

          const handleDelete = useCallback((id) => {
              let prevSiblingId = null;
              setBullets(prevBullets => { 
                  const foundTarget = findBulletAndParent(id, prevBullets); 
                  if (foundTarget?.node.isReadOnly) return prevBullets; 
                  const newBullets = structuredClone(prevBullets); 
                  const found = findBulletAndParent(id, newBullets); 
                  if (found) { 
                      prevSiblingId = found.index > 0 ? found.siblings[found.index - 1].id : found.parent?.id || null; 
                      if (found.parent) found.parent.updatedAt = Date.now(); 
                      found.siblings.splice(found.index, 1); 
                      return newBullets; 
                  } 
                  return prevBullets; 
              });
              removeFromRecentList(id);
              setTimeout(() => handleFocusChange(prevSiblingId, 'end', 'view'), 0);
          }, [handleFocusChange, findBulletAndParent, removeFromRecentList]);

          const handleMerge = useCallback((id) => {
              setBullets(prevBullets => {
                  const foundTarget = findBulletAndParent(id, prevBullets); if (!foundTarget || foundTarget.node.isReadOnly) return prevBullets;
                  if (foundTarget.index > 0) {
                      const newBullets = structuredClone(prevBullets); const found = findBulletAndParent(id, newBullets); const prevSibling = found.siblings[found.index - 1]; if (prevSibling.isReadOnly) return prevBullets;
                      const cursorPosition = prevSibling.text.length; 
                      prevSibling.text += found.node.text; 
                      prevSibling.children = [...prevSibling.children, ...found.node.children]; 
                      prevSibling.updatedAt = Date.now(); 
                      if (found.node.children.length > 0) prevSibling.isCollapsed = false; 
                      found.siblings.splice(found.index, 1); 
                      if (found.parent) found.parent.updatedAt = Date.now();
                      
                      removeFromRecentList(found.node.id);
                      updateRecentList(prevSibling.id, prevSibling.text, prevSibling.updatedAt || Date.now());
                      setFavoriteBullets(prev => prev.map(f => f.id === prevSibling.id ? { ...f, text: prevSibling.text } : f));

                      setTimeout(() => handleFocusChange(prevSibling.id, cursorPosition, 'edit'), 0); return newBullets;
                  } else {
                      if (foundTarget.node.text === '') { 
                          const newBullets = structuredClone(prevBullets); 
                          const found = findBulletAndParent(id, newBullets); 
                          const parentId = found.parent?.id || null; 
                          found.siblings.splice(found.index, 1); 
                          if (found.parent) found.parent.updatedAt = Date.now(); 
                          
                          removeFromRecentList(found.node.id);
                          
                          setTimeout(() => handleFocusChange(parentId, 'end', 'view'), 0); 
                          return newBullets; 
                      }
                  }
                  return prevBullets;
              });
          }, [findBulletAndParent, handleFocusChange, removeFromRecentList, updateRecentList]);

          const handleIndent = useCallback((id) => { 
              setBullets(prevBullets => { 
                  const foundTarget = findBulletAndParent(id, prevBullets); 
                  if (foundTarget?.node.isReadOnly) return prevBullets; 
                  const newBullets = structuredClone(prevBullets); 
                  const found = findBulletAndParent(id, newBullets); 
                  if (found && found.index > 0) { 
                      const prevSibling = found.siblings[found.index - 1]; 
                      if (prevSibling.isReadOnly) return prevBullets; 
                      const [movedNode] = found.siblings.splice(found.index, 1); 
                      movedNode.updatedAt = Date.now(); 
                      prevSibling.children.push(movedNode); 
                      prevSibling.isCollapsed = false; 
                      return newBullets; 
                  } 
                  return prevBullets; 
              }); 
              updateRecentList(id, undefined, Date.now());
              setTimeout(() => handleFocusChange(id, 'end', 'edit'), 0); 
          }, [handleFocusChange, findBulletAndParent, updateRecentList]);

          const handleOutdent = useCallback((id) => { 
              setBullets(prevBullets => { 
                  const foundTarget = findBulletAndParent(id, prevBullets); 
                  if (foundTarget?.node.isReadOnly) return prevBullets; 
                  const newBullets = structuredClone(prevBullets); 
                  const found = findBulletAndParent(id, newBullets); 
                  if (found && found.parent) { 
                      const parentInfo = findBulletAndParent(found.parent.id, newBullets); 
                      if(parentInfo && !parentInfo.node.isReadOnly){ 
                          const [movedNode] = found.siblings.splice(found.index, 1); 
                          movedNode.updatedAt = Date.now(); 
                          const subsequentSiblings = found.siblings.splice(found.index); 
                          movedNode.children.push(...subsequentSiblings); 
                          parentInfo.siblings.splice(parentInfo.index + 1, 0, movedNode); 
                          return newBullets; 
                      } 
                  } 
                  return prevBullets; 
              }); 
              updateRecentList(id, undefined, Date.now());
              setTimeout(() => handleFocusChange(id, 'end', 'edit'), 0); 
          }, [handleFocusChange, findBulletAndParent, updateRecentList]);

          const handleFoldAll = useCallback((id, collapse, recursive = false) => {
              setBullets(prev => {
                  const setCollapseRecursively = (nodes) => nodes.map(node => { const newNode = { ...node }; if (newNode.children.length > 0) { newNode.isCollapsed = collapse; newNode.children = setCollapseRecursively(newNode.children); } return newNode; });
                  const fold = (nodes) => nodes.map(node => { 
                      if (node.id === id) { 
                          const updatedNode = { ...node, isCollapsed: collapse }; 
                          if(recursive && updatedNode.children.length > 0) { 
                              updatedNode.children = setCollapseRecursively(updatedNode.children); 
                          } 
                          return updatedNode; 
                      } 
                      if (node.children.length > 0) {
                           const newChildren = fold(node.children);
                           if (newChildren !== node.children) return { ...node, children: newChildren };
                      }
                      return node; 
                  });
                  return fold(prev);
              });
          }, []);

          const handleMoveBullet = useCallback((id, direction) => { 
              setBullets(prevBullets => { 
                  const foundTarget = findBulletAndParent(id, prevBullets); 
                  if (foundTarget?.node.isReadOnly) return prevBullets; 
                  const newBullets = structuredClone(prevBullets); 
                  const found = findBulletAndParent(id, newBullets); 
                  if (!found) return prevBullets; 
                  const { siblings, index } = found; 
                  found.node.updatedAt = Date.now(); 
                  if (direction === 'up') { if (index > 0) { [siblings[index], siblings[index - 1]] = [siblings[index - 1], siblings[index]]; return newBullets; } } 
                  else { if (index < siblings.length - 1) { [siblings[index], siblings[index + 1]] = [siblings[index + 1], siblings[index]]; return newBullets; } } 
                  return prevBullets; 
              }); 
              updateRecentList(id, undefined, Date.now());
          }, [findBulletAndParent, updateRecentList]);

          const handleFocusParent = useCallback((id) => {
              const zoomedId = zoomedBulletIdRef.current; const currentBullets = bulletsRef.current;
              const findInScope = (nodes, targetId) => { for (const node of nodes) { if (node.id === targetId) return node; const f = findInScope(node.children, targetId); if (f) return f; } return null; };
              let scope = currentBullets; if (zoomedId) { const zoomedNode = findInScope(currentBullets, zoomedId); if (zoomedNode) scope = zoomedNode.children; else scope = []; }
              const findParent = (bulletId, nodes, parent = null) => { for (const node of nodes) { if (node.id === bulletId) return { node, parent }; const found = findParent(bulletId, node.children, node); if (found) return found; } return null; };
              const found = findParent(id, scope); if (found?.parent) handleFocusChange(found.parent.id, 'end', 'view');
          }, [handleFocusChange]);

          const handleFocusChild = useCallback((id) => { const currentBullets = bulletsRef.current; const find = (nodes) => { for(const node of nodes) { if (node.id === id) return node; const f = find(node.children); if(f) return f; } return null; }; const foundNode = find(currentBullets); if (foundNode && foundNode.children.length > 0 && !foundNode.isCollapsed) handleFocusChange(foundNode.children[0].id, 'start', 'view'); }, [handleFocusChange]);

          const handleExport = () => {
              const dataStr = JSON.stringify(bullets, null, 2); const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
              const now = new Date(); const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
              const sanitizedFileName = settings.fileName.replace(/[<>:"/\\|?*]/g, '_'); const exportFileDefaultName = `${sanitizedFileName}_bck_${timestamp}.json`;
              const linkElement = document.createElement('a'); linkElement.setAttribute('href', dataUri); linkElement.setAttribute('download', exportFileDefaultName); linkElement.click();
              addToast('Export started', 'success');
          };

          const handleImport = (data) => { setPendingImportData(data); setIsImportModalOpen(true); };
          const handleConfirmImport = (targetId) => {
              if (!pendingImportData) return;
              let nodesToImport = migrateBullets(pendingImportData); nodesToImport = regenerateIds(nodesToImport);

              const importedItems = [];
              const traverse = (nodes) => {
                  for(const n of nodes) {
                      importedItems.push({id: n.id, text: n.text, updatedAt: n.updatedAt || Date.now()});
                      traverse(n.children);
                  }
              };
              traverse(nodesToImport);
              setRecentBullets(prev => {
                  const combined = [...importedItems, ...prev];
                  combined.sort((a,b) => b.updatedAt - a.updatedAt);
                  return combined.slice(0, 12);
              });

              if (targetId === null) setBullets(prev => [...prev, ...nodesToImport]);
              else { const newBullets = structuredClone(bullets); const found = findBulletAndParent(targetId, newBullets); if (found && !found.node.isReadOnly) { found.node.children.push(...nodesToImport); found.node.isCollapsed = false; found.node.updatedAt = Date.now(); setBullets(newBullets); } }
              setIsImportModalOpen(false); setPendingImportData(null); addToast('Items imported successfully', 'success');
          };
          
          const handleAddItemToCurrentView = useCallback(() => {
              const newBullet = createNewBullet(); const zoomedId = zoomedBulletIdRef.current;
              if (zoomedId) { 
                  setBullets(prevBullets => { 
                      const newBullets = structuredClone(prevBullets); 
                      const found = findBulletAndParent(zoomedId, newBullets); 
                      if (found && !found.node.isReadOnly) { 
                          found.node.children.push(newBullet); 
                          found.node.isCollapsed = false; 
                          found.node.updatedAt = Date.now(); 
                          return newBullets; 
                      } 
                      return prevBullets; 
                  }); 
              }
              else { setBullets(prev => [...prev, newBullet]); }
              setTimeout(() => handleFocusChange(newBullet.id, 'start', 'edit'), 0);
              updateRecentList(newBullet.id, newBullet.text, newBullet.updatedAt || Date.now());
          }, [handleFocusChange, findBulletAndParent, updateRecentList]);

          const handleFocusMove = useCallback((direction, position = 'end', mode = 'view') => { 
            const currentFocusId = focusOptionsRef.current.id; 
            const visibleIds = visibleBulletIdsRef.current; 
            if (!currentFocusId) { 
              if (visibleIds.length > 0) handleFocusChange(visibleIds[0], position, mode); 
              return; 
            } 
            const currentIndex = visibleIds.indexOf(currentFocusId); 
            if (currentIndex === -1) return; 
            let nextIndex; 
            if (direction === 'down') { 
              nextIndex = currentIndex + 1; 
              if (nextIndex < visibleIds.length) handleFocusChange(visibleIds[nextIndex], position, mode); 
            } else { 
              nextIndex = currentIndex - 1; 
              if (nextIndex >= 0) handleFocusChange(visibleIds[nextIndex], position, mode); 
            } 
          }, [handleFocusChange]);

          const handleOpenSearch = () => { focusBeforeModalRef.current = currentFocusId; setIsSearchModalOpen(true); };
          const handleCloseSearch = () => { setIsSearchModalOpen(false); if (focusBeforeModalRef.current) { const idToRestore = focusBeforeModalRef.current; handleFocusChange(idToRestore, 'start', 'view'); setTimeout(() => handleFocusChange(idToRestore, 'end', 'view'), 0); focusBeforeModalRef.current = null; } };
          const handleTriggerLinkPopup = useCallback((bulletId, query, inputRef, selectionHandler) => { if (!inputRef.current) return; const rect = inputRef.current.getBoundingClientRect(); setLinkSelectionHandler({ handler: selectionHandler }); const POPUP_HEIGHT = 200; const windowHeight = window.innerHeight; let top = rect.bottom + window.scrollY; if (rect.bottom + POPUP_HEIGHT > windowHeight) top = rect.top + window.scrollY - POPUP_HEIGHT; setLinkPopupState({ isOpen: true, targetId: bulletId, query, position: { top, left: rect.left + window.scrollX }, suggestions: [], selectedIndex: 0 }); }, []);
          const handleCloseLinkPopup = useCallback(() => { setLinkPopupState(prev => ({ ...prev, isOpen: false })); setLinkSelectionHandler({ handler: null }); }, []);
          const handleLinkNavigate = useCallback((direction) => { setLinkPopupState(prev => ({ ...prev, selectedIndex: navigateSuggestions({ suggestions: prev.suggestions, selectedIndex: prev.selectedIndex }, direction) })); }, []);
          const handleLinkSelect = useCallback((callback) => { if (linkPopupState.suggestions[linkPopupState.selectedIndex]) callback(linkPopupState.suggestions[linkPopupState.selectedIndex]); }, [linkPopupState]);

          const handleTriggerTagPopup = useCallback((bulletId, query, inputRef, selectionHandler) => { if (!inputRef.current) return; const rect = inputRef.current.getBoundingClientRect(); setTagSelectionHandler({ handler: selectionHandler }); const POPUP_HEIGHT = 200; const windowHeight = window.innerHeight; let top = rect.bottom + window.scrollY; if (rect.bottom + POPUP_HEIGHT > windowHeight) top = rect.top + window.scrollY - POPUP_HEIGHT; setTagPopupState({ isOpen: true, targetId: bulletId, query, position: { top, left: rect.left + window.scrollX }, suggestions: [], selectedIndex: 0 }); }, []);
          const handleCloseTagPopup = useCallback(() => { setTagPopupState(prev => ({ ...prev, isOpen: false })); setTagSelectionHandler({ handler: null }); }, []);
          const handleTagNavigate = useCallback((direction) => { setTagPopupState(prev => ({ ...prev, selectedIndex: navigateSuggestions({ suggestions: prev.suggestions, selectedIndex: prev.selectedIndex }, direction) })); }, []);
          const handleTagSelect = useCallback((callback) => { if (tagPopupState.suggestions[tagPopupState.selectedIndex]) callback(tagPopupState.suggestions[tagPopupState.selectedIndex]); }, [tagPopupState]);
          
          const linkSuggestions = useMemo(() => {
              if (!linkPopupState.isOpen || !linkPopupState.query) return [];
              const flat = []; const traverse = (nodes, path) => { for(const n of nodes) { flat.push({ id: n.id, text: n.text, path }); traverse(n.children, [...path, n.text]); } }; traverse(bullets, []);
              const lowerQuery = linkPopupState.query.toLowerCase(); const filtered = flat.filter(b => b.text.toLowerCase().includes(lowerQuery)).slice(0, 50);
              return filtered;
          }, [bullets, linkPopupState.isOpen, linkPopupState.query]);
          
          useEffect(() => {
             setLinkPopupState(prev => {
                 if (JSON.stringify(prev.suggestions) === JSON.stringify(linkSuggestions)) return prev;
                 return { ...prev, suggestions: linkSuggestions, selectedIndex: 0 };
             });
          }, [linkSuggestions]);
          
          const tagSuggestions = useMemo(() => {
              if (!tagPopupState.isOpen) return [];
              const tags = new Set(); const traverse = (nodes) => { for(const n of nodes) { const matches = n.text.match(/#\w+/g); if (matches) matches.forEach(t => tags.add(t)); traverse(n.children); } }; traverse(bullets);
              const lowerQuery = tagPopupState.query.toLowerCase(); const filtered = Array.from(tags).filter(t => t.toLowerCase().includes(lowerQuery)).sort().slice(0, 50);
              return filtered;
          }, [bullets, tagPopupState.isOpen, tagPopupState.query]);
          
          useEffect(() => {
              setTagPopupState(prev => {
                  if (JSON.stringify(prev.suggestions) === JSON.stringify(tagSuggestions)) return prev;
                  return { ...prev, suggestions: tagSuggestions, selectedIndex: 0 };
              });
           }, [tagSuggestions]);

          // Define handleClearData to fix ReferenceError
          const handleClearData = () => {
              if (confirm("Are you sure you want to delete all data? This cannot be undone.")) {
                  setBullets(initialData);
                  setRecentBullets([]);
                  setFavoriteBullets([]);
                  addToast('Application data reset', 'info');
                  setIsSettingsModalOpen(false);
              }
          };

          const handleLinkClick = useCallback((text) => {
              const findIdByText = (nodes, searchText, exact) => {
                  const target = exact ? searchText : searchText.toLowerCase();
                  for (const node of nodes) {
                      const nodeText = exact ? node.text : node.text.toLowerCase();
                      if (nodeText === target) return node.id;
                      if (node.children.length > 0) {
                          const found = findIdByText(node.children, searchText, exact);
                          if (found) return found;
                      }
                  }
                  return null;
              };

              let targetId = findIdByText(bullets, text, true);
              if (!targetId) targetId = findIdByText(bullets, text, false);

              if (targetId) {
                  handleNavigate(targetId);
              } else {
                  setSearchQuery(text);
                  setIsSearchModalOpen(true);
                  addToast(`Link target "${text}" not found`, 'info');
              }
          }, [bullets, handleNavigate, addToast]);

          return (
              <div className="flex flex-col h-screen bg-white dark:bg-gray-900 text-[var(--main-color)] font-[family-name:var(--font-family)] overflow-hidden transition-colors duration-200">
                  <div className="flex-grow flex overflow-hidden">
                      <LeftSidebar isOpen={isSidebarOpen} recents={recentBullets} favorites={favoriteBullets} onNavigate={handleNavigate} />
                      <div className="flex-grow flex flex-col h-full overflow-hidden relative">
                          <Toolbar onImport={handleImport} onExport={handleExport} breadcrumbs={breadcrumbs} onBreadcrumbClick={handleZoom} fileName={settings.fileName} onOpenSettings={() => setIsSettingsModalOpen(true)} onGoToToday={handleGoToJournal} theme={theme} onThemeToggle={handleThemeToggle} onOpenSearch={handleOpenSearch} isSidebarOpen={isSidebarOpen} onToggleSidebar={() => { setIsSidebarOpen(prev => { db.keyValuePairs.put({ key: 'isSidebarOpen', value: !prev }); return !prev; }); }} isFavorite={isTargetFavorite} onToggleFavorite={handleToggleFavorite} canFavorite={!!targetFavoriteId} />
                          <div className="flex-grow overflow-y-auto p-4 sm:p-8" onClick={() => handleFocusChange(null)}>
                              <div className="max-w-4xl mx-auto pb-40">
                                  {displayedBullets.length === 0 ? (
                                      <div className="text-gray-400 dark:text-gray-500 italic mt-8 text-center cursor-pointer" onClick={(e) => { e.stopPropagation(); handleAddItemToCurrentView(); }}>Click to add a bullet</div>
                                  ) : (
                                      displayedBullets.map(bullet => <BulletItem key={bullet.id} bullet={bullet} level={0} onUpdate={handleUpdate} onAddSibling={handleAddSibling} onDelete={handleDelete} onIndent={handleIndent} onOutdent={handleOutdent} onFocusChange={handleFocusChange} onZoom={handleZoom} onFocusMove={handleFocusMove} onFocusParent={handleFocusParent} onFocusChild={handleFocusChild} onFoldAll={handleFoldAll} onMoveBullet={handleMoveBullet} currentFocusId={currentFocusId} focusPosition={focusPosition} focusMode={focusMode} searchQuery={searchQuery} onLinkClick={handleLinkClick} onTriggerLinkPopup={handleTriggerLinkPopup} onCloseLinkPopup={handleCloseLinkPopup} onLinkNavigate={handleLinkNavigate} onLinkSelect={handleLinkSelect} isLinkPopupOpen={linkPopupState.isOpen} linkPopupTargetId={linkPopupState.targetId} onTriggerTagPopup={handleTriggerTagPopup} onCloseTagPopup={handleCloseTagPopup} onTagNavigate={handleTagNavigate} onTagSelect={handleTagSelect} isTagPopupOpen={tagPopupState.isOpen} tagPopupTargetId={tagPopupState.targetId} isJournalRoot={bullet.text === DAILY_LOG_ROOT_TEXT} onNavigateTo={handleNavigate} onMerge={handleMerge} />)
                                  )}
                              </div>
                          </div>
                          <SearchModal isOpen={isSearchModalOpen} onClose={handleCloseSearch} bullets={bullets} onNavigate={handleNavigate} initialQuery={searchQuery} />
                          <SettingsModal isOpen={isSettingsModalOpen} onClose={() => setIsSettingsModalOpen(false)} onSave={setSettings} currentSettings={settings} onClearData={handleClearData} />
                          <ImportSelectionModal isOpen={isImportModalOpen} onClose={() => { setIsImportModalOpen(false); setPendingImportData(null); }} onConfirm={handleConfirmImport} bullets={bullets} />
                          <ToastContainer toasts={toasts} removeToast={removeToast} />
                          {linkPopupState.isOpen && <LinkPopup suggestions={linkSuggestions} selectedIndex={linkPopupState.selectedIndex} onSelect={(b) => linkSelectionHandler.handler && linkSelectionHandler.handler(b)} position={linkPopupState.position} containerRef={linkPopupRef} />}
                          {tagPopupState.isOpen && <TagPopup suggestions={tagSuggestions} selectedIndex={tagPopupState.selectedIndex} onSelect={(t) => tagSelectionHandler.handler && tagSelectionHandler.handler(t)} position={tagPopupState.position} containerRef={tagPopupRef} />}
                      </div>
                  </div>
                  <footer className="flex-shrink-0 p-1 px-4 text-sm text-[var(--main-color)] border-t border-gray-200 dark:border-gray-700 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm flex justify-between items-center z-10 w-full">
                      <div className="flex items-center gap-2 min-w-0"><span title={settings.fileName} className="truncate">{settings.fileName}</span></div>
                      <a href="https://github.com/jaroet/JaRoet-Outliner/releases" target="_blank" rel="noopener noreferrer" className="flex-shrink-0 ml-2 hover:underline" title="View Release Notes">Version 0.1.37</a>
                  </footer>
              </div>
          );
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>